# Двоичные деревья

Дерево, степень вершины которого не превосходит $2$, называется **двоичным** (**бинарным**).

В двоичном дереве детей вершины называют соответственно **левым** и **правым** ребенком.

## Сбалансированность двоичных деревьев

Если в двоичном дереве $N$ вершин, то высота дерева может варьироваться от $N$ (называется "бамбуком") до $\lceil{\log_2{N}}\rceil$.

Дерево с высотой $O(\log{N})$ называется **сбалансированным**.

### Полное двоичное дерево

Одним из примеров сбалансированного двоичного дерева является **полное** дерево - все вершины имеют степень $2$ либо $0$.

Покажем это:

- Пусть высота дерева равна $H$.
- На глубине $i$ такое дерево будет содержать ровно $2^{(i - 1)}$ вершин.
- Всего вершин в дереве будет $N = 2^0 + 2^1 + \dots + 2^{(H - 1)} = 2^H - 1$. 
- Отсюда получаем $H = \log_2{(N + 1)} = \lceil{\log_2{N}}\rceil = O(\log{N})$.

### Другие виды баланса

В реальной жизни далеко не все двоичные деревья являются полными.

В то же время существуют и более "общие" способы сделать дерево сбалансированным.

Например, для каждой вершины $v$ может выполняться определенное условие:

- разница **размеров** левого и правого поддеревьев не превосходит $1$: $|S_L - S_R| \le 1$;
- разница **высот** левого и правого поддеревьев не превосходит $1$: $|H_L - H_R| \le 1$.

Очевидно, что существуют и другие способы балансировки деревьев, но два приведенных выше являются наиболее простыми.

Обратите внимание, что полное дерево сбалансированно и по первому, и по второму критерию.

## Представление и хранение двоичного дерева

### Указатели на динамическую память

В случае использования указателей на динамическую память узлы двоичного дерева очень похожи на узлы связного списка (только вместо указателей на `prev` / `next` хранятся указатели на `left` / `right` / `parent` (опционально)).

### Идентификаторы (позиции в массиве)

Для случая использования идентификаторов (позиций в массиве) существует интересная форма нумерации вершин двоичного дерева:

- корневая вершина имеет идентификатор $1$;
- дети вершины $v$ имеют номера $2 \cdot v$ и $2 \cdot v + 1$.
- при такой нумерации предок вершины $v$ имеет номер $\lfloor\frac{v}{2}\rfloor$

Данная форма нумерации упрощает обработку соответствующих связей - достаточно знать идентификатор самой вершины, чтобы найти всех её соседей.

В то же время есть и отрицательные стороны такого подхода. В общем случае идентификатор имеет значение вплоть до $O(2^H)$. 

- В случае сбалансированного дерева это ограничение превращается в $O(N)$ - почти все ячейки заполнены;
- в случае же сильной разбалансировки дерева множество ячеек массива остаются пустыми и память расходуется неэффективно. 

## Обход двоичного дерева

#### Примеры спусков

##### Самая левая вершина

Нерекурсивная реализация:

```cpp
Node* go(Node* start = root) {
  Node* node = start;
  while (node->left != nullptr) {
    node = node->left;
  }

  return node;
}
```

Рекурсивная реализация

```cpp
Node* go(Node* node = root) {
  if (node->left == nullptr) return node;
  return go(node->left);
}
```

##### Поочередный спуск

Сначала идём направо, потом налево, потом опять направо и т.д.

Нерекурсивная реализация:

```cpp
Node* go(Node* start = root, bool to_right = true) {
  Node* node = start;
  while (true) {
    if (to_right) {
      if (node->right == nullptr) return node;
      node = node->right;
    } else {
      if (node->left == nullptr) return node;
      node = node->left;
    }
    
    to_right = !to_right;
  }
}
```

Рекурсивная реализация

```cpp
Node* go(Node* node = root, bool to_right = true) {
  if (to_right) {
    if (node->right == nullptr) return node;
    return go(node->right, false);
  } else {
    if (node->left == nullptr) return node;
    return go(node->left, true);
  }
}
```

### Полный обход дерева

#### Направление и порядок обхода

Различают три вида обходов по порядку обработки вершины и её поддеревьев:

- LVR - сначала левое поддерево, затем вершина, затем правое;
- LRV - сначала левое, затем правое, затем вершина;
- VLR - сначала вершина, затем левое, затем правое.

Аналогично есть "зеркальные" аналоги, где сначала идут направо, а потом уже налево.

#### Рекурсивные примеры реализации

##### Вывод вершин в порядке LVR

```cpp
void print_tree(Node* node) {
  if (node == nullptr) return;
  
  print_tree(node->left);
  
  std::cout << node->value << std::endl;
  
  print_tree(node->right);
}
```

##### Вывод глубины каждой вершины в порядке VLR

```cpp
void print_depth(Node* node, int depth = 1) {
  if (node == nullptr) return;
  
  std::cout << node->value << " " << depth << std::endl;
  
  print_depth(node->left, d + 1);
  print_depth(node->right, d + 1);
}
```

##### Вычисление высоты дерева в порядке LRV

```cpp
void calc_height(Node* node) {
  if (node == nullptr) return 0;
  
  int left_height = calc_height(node->left);
  int right_height = calc_height(node->right);
  
  return std::max(left_height, right_height) + 1;
}
```

#### Нерекурсивный вариант полного обхода

Для каждого узла можно реализовать нерекурсивный алгоритм перехода к "следующему" узлу в обходе (аналог `next` в связном списке). Только в отличие от связного списка в двоичном дереве `next` является функцией (правилом перехода), а не ссылкой на конкретный узел.

В таком случае сам обход становится аналогичным итерации по последовательности:

```cpp
for (Node* node = first(); node != nullptr; node = next(node)) {
  // process node
}
```

Здесь `first` обозначает первый (стартовый) узел в обходе.

Обратите внимание, что по аналогии с `next` всегда можно построить функцию `prev`, а по аналогии с `first` - функцию `last`.

##### Реализация `next`

Реализация сильно зависит от выбранного порядка и направления обхода.

В качестве примера опишем `next` для порядка обхода LVR:

- в узле необходимо хранить указатель на родительский узел (`parent`);
- если у вершины есть правый ребенок - переходим в него;
  - далее итеративно переходим в левого ребенка, пока он существует.
  - таким образом вы найдете "самый левый узел в правом поддереве" - это результат, возвращаем его.
- если у вершины нет правого ребенка, то итеративно поднимаемся в родителей.
  - если мы поднялись из левого ребенка, то текущий узел - результат, возвращаем его.
  - если мы поднялись выше корня, то стартовый узел был последним в обходе, обход завершен.

Пример реализации:

```cpp
Node* next_lvr(Node* node) {
  if (node->right != nullptr) {
    Node* next = node->right;
    while (next->left != nullptr) next = next->left;
    
    return next;
  } else {
    while (node->parent != nullptr) {
      Node* parent = node->parent;
      if (node == parent->left) return parent;
    }
    
    return nullptr;
  }
}
```
