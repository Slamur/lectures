# Компаратор

Если отношение порядка является математическим абстрактом, то его реализацией в языках программирования является **компаратор**.

В языках можно встретить два основных варианта компаратора:

- прямой аналог отношения порядка $F$ - булевая функция "меньше".
- комбинация отношений порядка $F$ и эквивалетности $G$ - функция, возвращающая один из трёх результатов "меньше" / "равно" / "больше".

Также некоторые языки позволяют определить специальные компараторы для целого типа данных вместо определения для каждой сортировки по отдельности.

# C++

## Упорядочивание

- `std::reverse` осуществляет переворот последовательностей;
- `std::sort` и `std::stable_sort` осуществляют нестабильную и стабильную сортировки, соответственно.
  - в качестве дополнительных параметров можно передать компаратор и дополнительные политики.

## Компаратор

C++ использует принцип булевого компаратора (оператор $x < y$).

Для сравнения:

- можно определить отдельную булевую функцию сравнения, специфичную для данной сортировки.
  - в том числе лямбда-функцию, которая может быть описана прямо на месте параметра функции.

- на уровне типа данных можно определить `operator<`.
  - на его основе определяются все остальные операторы сравнения.
  - (до С++ 20) используется напрямую в сортировках.

- (начиная с C++ 20) вводится новый оператор `<=>` ("spaceship operator").
  - возвращает `less` / `equal` / `greater` результаты (необходимо сравнивать с $0$).

- (начиная с С++ 20) сортировки используют функциональный объект `std::less`.
  - по умолчанию вызывает `operator<` для переданной пары значений.

## Лексикографическое сравнение

В С++ по умолчанию определено лексикографическое сравнение для следующих структур данных:

- `std::string`;
- `std::pair`;
- `std::tuple` и `std::tie`;
- `std::array`;
- `std::vector`;
- большинство других типов-последовательностей.

Соответственно, чаще всего вместо описания сложной логики компаратора:

- в случае класса с несколькими атрибутами рекомендуется упаковка в `std::tie`.
- в случае комбинации нескольких значений рекомендуется упаковка в `std::pair` или `std::tuple`.

# Java

## Упорядочивание

- статический класс `Arrays` предоставляет метод `sort` для массивов.
  - дополнительные параметры перегрузок - границы сортируемого отрезка и компаратор.
  - сортировки для примитивных типов и для объектных типов отличаются.
- статический класс `Collections` предоставляет аналогичный метод `sort` для интерфейса `List`.
  - также предоставляет метод `reverse`.

## Компаратор

Java использует принцип трехстороннего сравнения ("меньше" / "равно" / "больше"):

- возвращается целое число;
- отрицательное значит "меньше";
- положительное значит "больше";
- ноль значит "равно".

Для сравнения:

- интерфейс `Comparator` используется для описания логики сравнения, не привязанной к типу данных.
  - необходимо реализовать метод `int compare(T a, T b)`.
  - является **функциональным интерфейсом** - может быть выражен лямбда-функцией.

- интерфейс `Comparable` определяется на уровне целого типа данных.
  - необходимо реализовать метод `int compareTo(T other)`.

## Лексикографическое сравнение

В Java лексикографический компаратор определен только для структур данных `String` и `StringBuilder` (через `Comparable`).

Коллекции и массивы не имеют компаратора по умолчанию.

# Python

## Упорядочивание

Для класса `list` определены следующие операции:

- методы `sort` и `reverse` для in-place упорядочивания.
- функции `sorted` и `reversed` для создания упорядоченной копии.
  - `[::-1]` также создаёт перевернутую копию списка.

Сортировки (`sort` и `sorted`) принимают следующие дополнительные параметры:

- `reverse` для упорядочивания по убыванию (эффективнее, чем сортировка + переворот).
- `key` - функция для вычисления _ключа сортировки_.

## Компаратор

Для сравнения объектов:

- на уровне типа данных можно переопределить операторы `__lt__` и другие.
- на уровне сортировок можно задать ключ сортировки.
  - для использования трехстороннего сравнения необходимо преобразовать данное сравнение в ключ специальной функцией.

## Лексикографическое сравнение

В Python по умолчанию определено лексикографическое сравнение для следующих структур данных:

- `str`;
- `tuple`;
- `list`.

Соответственно, чаще всего вместо описания сложной логики компаратора достаточно упаковать значения в `tuple` или `list`.
