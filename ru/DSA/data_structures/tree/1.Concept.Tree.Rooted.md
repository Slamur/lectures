# Деревья

## Предисловие

В этой лекции мы будем обсуждать определенные виды деревьев.

Вообще деревья являются частным случаем графов - и изучаются, соответственно, в рамках теории графов. В то же время знакомиться с древовидными структурами данных можно и без понимания всех тонкостей и деталей.

Соответственно, я постараюсь в рамках данной лекции дать лишь самые необходимые для понимания определения и термины, относящиеся к деревьям.

Для желающих больше познакомиться с основами теории графов - добавлена ссылка на курс в рамках Codeforces EDU.

## Что такое дерево?

Что такое связный список? Набор узлов, связанных между собой определенным образом.

То же самое можно сказать и про деревья - тоже узлы, тоже связи с определенными условиями.

Так как дерево является частным случаем графа, то узлы дерева также называют **вершинами**, а связи - **ребрами**.

Давайте построим с вами дерево из узлов:

- в отличие от большинства деревьев из реального мира деревья в Computer Science обычно "растут" сверху вниз.

- соответственно, для начала зафиксируем так называемый **корневой** узел $R$ - именно с него мы будем начинать любые действия с нашим деревом (сравните с "головным" узлом в связном списке).

- к корневому узлу подвесим несколько (возможно ноль) узлов.

- к некоторым из подвешенных узлов (возможно нулю) подвесим еще узлы.

- и так далее.

## Основные термины

### Корневое дерево

На самом деле мы построили именно "корневое (подвешенное)" дерево. 

В общем случае дерево не обязано иметь корень, но в рамках данного курса мы будем работать только с корневыми деревьями, поэтому в дальнейшем под "деревом" мы будем подразумевать именно "корневое дерево", если явно не сказано иного.

### Размер дерева

Чаще всего под **размером дерева** $S$ понимают количество вершин $N$ в нём.

Обратите внимание, что даже одна вершина является корректным деревом размера $1$.

Также существует понятие пустого дерева (размер $0$), но чаще всего это актуально в рамках определенного контекста.

Обратите внимание, что в дереве размером $N$ **количество связей** равно $(N - 1)$.

### Пути в дереве

**Путём** длины $k$ будем называть последовательность узлов $v_1$, $v_2$, $\dots$, $v_k$ таких, что существуют связи между $v_1$ и $v_2$, между $v_2$ и $v_3$ и так далее.

**Простым** путём называют путь, где все вершины уникальны. В дальнейшем будем считать, что все пути в рамках лекции подразумеваются простыми.

Путём от вершины $v$ **до корня** будем называть путь, где $v_1 = v$, а $v_k = R$.

### Родственные связи

В дереве чаще всего используются четыре обозначения связей между узлами:

- узел $p$ является **родителем** узла $v$, если узел $p$ является вторым узлом ($v_2$) в пути от $v$ до корня.
- $v$ является **ребёнком** узла $p$, если узел $p$ - родитель вершины $v$.

- узел $p$ является **предком** узла $v$, если узел $p$ лежит где-то на пути от $v$ до корня (включая саму $v$).
- узел $v$ является **потомком** узла $p$, если узел $p$ - предок вершины $v$.

### Степень вершины

**Степенью** вершины $deg_v$ называют количество **детей** у вершины $v$.

Узел со степенью $0$ называется **листовым** (более распространенное название) или **терминальным**.

Важно, что независимо от структуры дерева сумма степеней вершин равна $(N - 1)$ - по количеству ребер в дереве.

### Поддерево вершины

**Поддеревом** вершины $v$ называют подмножество всех её **потомков** со связями между ними.

По определению корнем поддерева вершины $v$ является сама вершина $v$.

Также можно сказать, что поддерево вершины $v$ состоит из:

- самой вершины $v$;
- поддеревьев её детей $c_1$, $c_2$, $\dots$;
- ребер от $v$ к её детям.

### Высота и глубина вершины

**Глубина** вершины $v$ - длина пути от корня до $v$.

По сути глубина вершины равна количеству её предков.

**Высота** вершины $v$ - длина пути от $v$ до её потомка с наибольшей _глубиной_.

**Высота** всего дерева $H$ равна наибольшей высоте среди всех вершин, то есть высоте корня $R$. 

## Представление и хранение дерева

Как и у связного списка, узлы дерева чаще всего представляют собой экземпляры специальных классов, хранящих значение `value` и связи на какие-либо другие узлы.

Связи обычно представлены одним из двух способов:

- узлы хранятся в динамической памяти, связи - встроенный механизм указателей / ссылок языка;
- узлы хранятся в массиве, связи - позиции (идентификаторы) узлов в рамках данного массива.

Структура дерева обычно хранит один важный атрибут - это указатель / идентификатор корневого узла $R$.

### Представление "узел - родитель"

Корневое дерево может быть задано набором ассоциаций "узел - родительский узел" (всего $N - 1$ ассоциация).

Очевидно, что для узла $R$ такой ассоциации нет (так как у него нет родителя).

Чаще всего эта форма представления является промежуточной и используется для пересылки дерева по каналу информации.

## Обход дерева

### Спуск по дереву

**Спуском** обычно называют перемещение из корня в какую-то одну фиксированную вершину по ребрам "родитель - ребенок".

Спуск может быть реализован как нерекурсивно, так и рекурсивно.

В случае рекурсивной реализации возможно выполнение действий на обратном пути - так называемые действия **на возврате**.

#### Асимптотика спуска

Независимо от вида спуска асимптотика будет равна $O(H)$, так как в худшем случае спуск будет производиться в самый глубокий узел дерева.

### Полный обход дерева

Обрабатывает **все** вершины и ребра дерева в каком-то определенном порядке. Важно, что каждая вершина / ребро обрабатываются $O(1)$ раз.

Обычно описывается рекурсивно (но нерекурсивная реализация возможна).

#### Асимптотика обхода

Независимо от вида обхода асимптотика будет равна $O(N)$:

- в дереве всего $(N - 1)$ ребро, каждое ребро обрабатывается $O(1)$ раз и проходится два раза - из родителя в ребенка и из ребенка в родителя.
- в дереве всего $N$ вершин, каждая обрабатывается $O(1)$ раз и посещается ровно один раз при спуске и $deg_v$ раз при подъёме.

Суммарно получается $(N - 1) \cdot (O(1) + 2) + N \cdot O(1) + \sum{(1 + deg_v)} = O(N)$ посещений / переходов / обработок.