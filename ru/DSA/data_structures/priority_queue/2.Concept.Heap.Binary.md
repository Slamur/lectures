# Двоичная куча

На самом деле кроме деревьев поиска существуют и другие виды деревьев, способных эффективно выполнять некоторые операции. Одна из таких структур - **двоичная куча**, умеющая быстро выполнять следующие операции:

- добавить значение;
- получить / удалить экстремум.

В дальнейшем без потери общности мы будем говорить о двоичной куче **на минимум**, если явно не сказано иного.

Также в рамках лекции мы будем использовать слово "куча" как синоним к двоичной куче, если иного не указано явно.

## Внутреннее устройство

### Правило кучи

Двоичная куча представляет из себя двоичное дерево, причем для любой пары "родитель $p$ - ребёнок $v$" верно, что значение в $p$ не больше, чем значение в $v$.

Данное свойство называется "**правилом кучи**" и именно оно позволяет выполнять описанные выше операции эффективно.

Например, из-за правила кучи именно корневой узел содержит минимальный элемент. Таким образом, получение доступа к экстремуму производится за $O(1)$.

### Двоичное дерево, но не поиска

Обратите внимание, что правило кучи работает лишь на пару "родитель - ребёнок". Оно никак не говорит о связи между двумя детьми одной и той же вершины. 

Таким образом, значения в левом и правом сыновьях вершины (а, соответственно, и поддеревьях) никак между собой не связаны. Это приводит к тому, что куча **не может** эффективно выполнять **поиск** значения - не хватает информации, чтобы правильно выбирать путь при спуске.

### Почти полное дерево

Куча является **почти полным** деревом: если высота кучи равна $H$, то все слои с $1$ до $H - 1$ заполнены полностью, а частично может быть заполнен только последний слой "слева направо".

Таким образом, всего в куче с высотой $H$ может быть от $2^{H - 1}$ до $2^H - 1$ узлов.

Если всего в куче $N$ узлов, то получается $H \in [\log{(N + 1)}; \log{N} + 1] = O(\log{N})$.

Отсюда следует, что куча - **сбалансированное** двоичное дерево.

#### Реализация на массиве

Так как куча - сбалансированное двоичное дерево, то она может быть эффективно реализована **на массиве** при помощи следующей нумерации:

- корень находится в позиции $1$;
- левый ребёнок вершины $v$ имеет номер $2 \cdot v$, правый - $2 \cdot v + 1$.
  - таким образом номер родителя вершины $v$ равен $\lfloor\frac{v}{2}\rfloor$.

Дополнительную информацию про данный способ реализации вы можете найти в [лекции про двоичные деревья](https://gist.github.com/Slamur/d856357624ac9b3afdbaf99dbb0bace9#идентификаторы-позиции-в-массиве).

## Операции

Правило кучи является её важнейшим **инвариантом**. Поэтому после любого изменения кучи необходимы дополнительные действия по поддержанию инварианта - подъём и спуск узла.

### Подъём узла (upheap)

Данный процесс восстанавливает инвариант, если узел $v$ изначально находится **ниже**, чем должен быть.

Пока узел $v$ не является корнем дерева, будем выполнять итеративно следующие операции:

- пусть $p$ - текущий родитель узла $v$;
- если $value_p \le value_v$, то процесс закончен;
- иначе правило кучи для пары $(p, v)$ нарушено - исправим это, поменяв местами $p$ и $v$.

В худшем случае получится $H - 1 = O(H) = O(\log{N})$ итераций подъёма.

#### Пример реализации на C++ 

```cpp
void up_heap(size_t v) {
  while (v != root) {
    size_t p = v / 2;
    if (values[p] <= values[v]) break;
    
    std::swap(values[p], values[v]);
    v = p;
  }
}
```

### Спуск узла (downheap)

Данный процесс восстанавливает инвариант, если узел $v$ изначально находится **выше**, чем должен быть.

Пока $v$ не является листовым узлом дерева, будем выполнять следующие операции:

- пусть $vl$ и $vr$ - текущие дети узла $v$;
- пусть $value_{vl} < value_{vr}$ (для обратного случая действия аналогичны);
- если $value_v \le value_{vl}$, то процесс закончен;
- иначе правило кучи для пары $(v, vl)$ нарушено - исправим это, поменяв местами $v$ и $vl$.

В худшем случае получится $H - 1 = O(H) = O(\log{N})$ итераций спуска.

#### Пример реализации на C++ 

```cpp
void down_heap(size_t v) {
  while (true) {
    size_t min_v = v;
    
    size_t vl = v * 2;
    if (vl < values.size() && values[min_v] > values[vl]) min_v = vl;
    
    size_t vr = vl + 1;
    if (vr < values.size() && values[min_v] > values[vr]) min_v = vr;
    
    if (v == min_v) break;
    
    std::swap(values[v], values[min_v]);
    v = min_v;
  }
}
```

### Добавление значения

Нижний слой кучи обычно заполняют "слева направо". В случае реализации на массиве это означает, что все узлы от $1$ до $N$ являются заполненными. 

Поэтому добавим новое значение в наименьшую свободную позицию $(N + 1)$. Такое добавление могло нарушить инвариант только относительно родителя данного значения, поэтому вызовем **upheap** для исправления инварианта.

#### Пример реализации на C++ 

```cpp
void push(T value) {
  values[++last] = value;
  up_heap(last);
}
```

### Доступ к экстремуму

Данная операция не производит каких-либо изменений кучи, поэтому дополнительные действия не требуются.

Как вы помните, эестремум всегда лежит в корневом узле дерева, поэтому доступ осуществляется за $O(1)$.

#### Пример реализации на C++ 

```cpp
T top() {
  return values[root];
}
```

### Удаление экстремума

Сам экстремум найти и удалить не представляет сложности - вы уже знаете, что он находится в корневом узле.

Основной проблемой является поддержание целостности кучи после удаления.

Может показаться, что можно просто поставить на место корня одного из его детей. Получившуюся "дырку" можно будет итеративно закрывать, спускаясь всё ниже и ниже.

Проблема в том, что после такого исправления куча почти наверняка перестанет быть почти полным деревом.

Вместо этого на место корня поставим узел, находящийся на позиции $N$ (самая последняя занятая позиция).

Данное действие может нарушить правило кучи для нового корня и его детей, поэтому для исправления инварианта вызовем **downheap** для корня.

#### Пример реализации на C++ 

```cpp
void pop() {
  std::swap(values[root], values[last--]);
  down_heap(root);
}
```

### Вставка с удалением экстремума

В некоторых ситуациях размер кучи должен оставаться постоянным - соответственно, при добавлении нового значения необходимо удалить экстремум.

Да, можно выполнить две независимые операции `push` и `pop`, но в данной ситуации их можно объединить.

- Если новое значение меньше либо равно экстремуму, то никак вообще не изменяем кучу - ведь новое значение и будет удалено.
- Иначе поставим новое значение **сразу** на корневую позицию и вызовем downheap. Таким образом и корень будет удалён, и новое значение будет корректно помещено в кучу.

Данный способ позволяет пропустить этап upheap - асимптотика не меняется, но общее количество перемещений узлов уменьшается.

#### Пример реализации на C++ 

```cpp
void pushpop(T value) {
  if (value <= values[root]) return;
  
  values[root] = value;
  downheap(root);
}
```

## Построение

### Последовательные вставки

Начнём с пустой кучи и будем вставлять элементы по очереди через операцию `push`. 

Пусть всего мы вставим $N \le 2^H - 1$ значение. В худшем случае каждое новое значение будет подниматься с самого низа до корня, поэтому суммарное количество подъёмов будет равно $0 \cdot 2^0 + 1 \cdot 2^1 + \dots + (H - 1) \cdot 2^{(H - 1)}$.

В итоге мы получаем $2^H \cdot H - 2 \cdot (2^H - 1) = O(H \cdot 2^H)$ на все $N$ операций добавления.

Так как $H = O(\log_2{N})$, то $O(H \cdot 2^H) = O(\log{N} \cdot N)$, откуда амортизированная оценка вставки значения при построении кучи равна $O(\log{N})$. 

Результат может показаться очевидным (ведь мы и так знали, что вставка в кучу работает за $O(\log{N})$), но в общем случае асимптотика построения структуры с нуля бывает не такой очевидной, как кажется.

### На основе целой последовательности

Дана последовательность $a$ длины $N \le 2^H - 1$, необходимо построить на её основе кучу.

Первым делом скопируем последовательность в массив, на котором куча будет строиться. Далее будем перебирать элементы от $N$ до $1$, вызывая для каждого элемента **downheap**.

Алгоритм является корректным, так как при каждом вызове downheap оба поддерева текущей вершины уже удовлетворяют правилу кучи.

В худшем случае каждый узел спустится до уровня $H$, то есть всего будет сделано $0 \cdot 2^{H - 1} + 1 \cdot 2^{H - 2} + \dots + (H - 1) \cdot 2^0$ спусков.

В итоге получается $2^H - H + 1 = O(2^H)$ операций спуска на всё построение. Так как $H = O(\log_2{N})$, то $O(2^H) = O(N)$. 

Такой подход преобразования массива в кучу называется **heapify**.

Можно заметить, данный способ является асимптотически более эффективным, чем $N$ последовательных вставок. В то же время в большинстве ситуаций сценарий изначального построения кучи не будет играть решаюшую роль в итоговой эффективности алгоритма.

#### Пример реализации на C++ 

В данном примере используется 0-индексация массива и кучи. Формулы родителей и детей немного изменяются, но на суть это не влияет.

```cpp
void heapify(std::vector<T>& values) {
  for (size_t v = values.size(); v > 0; --v) {
    down_heap(values, v - 1);
  }
}
```

## Модификации

### Удаление не экстремума

Иногда требуется удалять из кучи заданное значение, а не только экстремум.

#### Внутренняя обработка

Дополнительно будем поддерживать словарь "значение - соответствующий ему узел в дереве". Если могут храниться одинаковые значения, то поддерживается очередь из узлов (удаляется всегда первый в очереди).

Таким образом, при запросе удаления узла $v$ достаточно перенести туда последний элемент кучи, после чего вызвать по очереди upheap и downheap.

Вызов обеих процедур необходим, так как в этом случае неизвестно, в какую сторону нарушается правило кучи при вставке последнего элемента.

#### Пример реализации на C++ 

```cpp
void erase(const T& value) {
  size_t v = nodes[value];

  std::swap(values[v], values[last]);
  nodes[values[v]] = v;
  
  up_heap(v);
  down_heap(v);
}
```


#### Внешняя обработка

Чаще внутреннюю структуру кучи изменить нельзя, поэтому используют метод, аналогичный удалению из очереди. 

Добавляется вторая куча с такими же правилами экстремума, после чего запрос удаления разбивается на два действия:

- при самом запросе удаления исходная куча не изменяется, а искомое значение вставляется во вторую кучу;
- перед запросом доступа / удаления экстремума производится итеративное удаление эктремумов обеих куч, если они совпадают.

#### Пример реализации на C++ 

```cpp
void erase(Heap& remove_heap, const T& value) {
  removeHeap.push(value);
}

void ensure(Heap& heap, Heap& remove_heap) {
  while (remove_heap.size() > 0 && heap.top() == remove_heap.top()) {
    heap.pop();
    remove_heap.pop();
  }
}

T top(Heap& heap, Heap& remove_heap) {
  ensure(heap, remove_heap);
  return heap.top();
}

void pop(Heap& heap, Heap& remove_heap) {
  ensure(heap, remove_heap);
  heap.pop();
}
```

### Изменение значения в узле

По сути данный сценарий может быть представлен как удаление старого значения и вставка нового значения.

При внутреннем способе обработки (словарь позиций) можно использовать парадигму `push_pop` - вставлять новое значение сразу на место старого, после чего вызывать upheap и downheap.

При внешней обработке (вторая куча) можно вставлять новое значение сразу, а старое удалять "по требованию".

## Куча или дерево поиска?

Реализация кучи на массиве (по сравнению с узлами в динамической памяти у большинства деревьев поиска) позволяет уменьшить расходы как на добавление новых узлов, так и на доступ к существующим узлам. 

Поэтому, хотя операции кучи и имеют аналогичную дереву поиска асимптотику $O(\log{N})$, в большинстве ситуаций они оказываются **неасимптотически эффективнее**.

В большинстве задач данная разница не будет иметь какого-то важного значения, но в случае проблем с эффективностью по времени кучу следует рассматривать в первую очередь.

## Другие кучи

На самом деле двоичная куча - лишь одна из множества семейства куч. 

Примеры существующих куч:

- биномиальная куча;
- фибоначчиевая куча;
- левосторонняя куча;
- и многие другие.

Все кучи являются деревьями (или набором деревьев) и обладают схожим набором основных операций, но могут иметь улучшенные асимптотики для некоторых из них.

В отличие от двоичной кучи, большинство куч строятся на узлах в динамической памяти, что может негативно сказываться на итоговой константе. Поэтому двоичная куча является самым простым и достаточно эффективным выбором для большинстве ситуаций.

# Сортировка кучей

Легко понять, что с помощью кучи можно производить сортировку за $O(N \cdot \log{N})$ с помощью $N$ вызовов `extract_extremum`.

## С дополнительной памятью

На основе массива строим кучу на минимум как отдельную структуру данных. 

После чего по очереди достаём минимальное значение и вставляем его в соответствующую позицию.

#### Пример реализации на C++ 

```cpp
void sort(std::vector<T>& a) {
  heap_min h(a.begin(), a.end());
  
  for (size_t i = 0; i < a.size(); ++i) {
    a[i] = h.top();
    h.pop();
  }
}
```

## Без дополнительной памяти

На самом деле возможна сортировка массива с использованием идеи двоичной кучи без дополнительной памяти.

- Выполним **heapify на максимум** на данном массиве.
- Будем итеративно выполнять `extract_extremum` и вставлять полученный максимум в соответствующую позицию в конце массива.

Таким образом, на $i$-й итерации позиции $[1; i]$ будут хранить значения по правилу кучи, а позиции $[i + 1; N]$ - в сортированном по возрастанию порядке.

#### Пример реализации на C++ 

```cpp
void sort(std::vector<T>& a) {
  heapify_max(a);
  
  for (size_t i = a.size(); i > 0; --i) {
    std::swap(a[0], a[i - 1]);
    down_heap(a, 0);
  }
}
```
