# Applications

## Indexing

### Задача

**Условие**: Поддержать в стеке операцию `get(index)` за $O(1)$ (нумерация от вершины стека).

**Решение**: использование динамического массива автоматически добавляет такую возможность без дополнительных модификаций.

## Multipop

### Задача

**Условие**: Поддержать в стеке операцию `multipop(k)` за $O(k)$ - извлечь из стека $k$ верхних значений.

Оценить **амортизированную сложность** данной операции.

**Решение**: не будем ничего делать лишнего - просто $k$ раз вызовем операцию `pop`.

**Амортизированную сложность** докажем бухгалтерским методом:

- Допустим в стек было суммарно положено $N$ значений.
- Выдадим каждому значению по $2$ монеты: одна на добавление, одна на извлечение.
- Независимо от параметров $k$ суммарно на все `multipop` будет потрачено не более $N$ монет.
- Учитывая $N$ монет на вставку, получаем амортизированную сложность не более $\frac{N + N}{N} = O(1)$ на вставку / извлечение.

## Minimum in stack

### Задача

**Условие**: поддержать в стеке операцию `min()` за $O(1)$ - минимальное значение среди лежащих внутри стека.

**Решение**: будем хранить в стеке пары:

- собственно значение `value`;
- минимум среди всех значений, лежащих **под** `value` (включая само `value`).

В таком случае ответ на запрос - второй элемент пары, лежащей на вершине стека.

#### Пример реализации

```cpp
template<typename T>
struct MinimumStack
{
  using info_t = std::pair<T, T>;

  std::stack<info_t> stack;
  T inf; // special value for the "empty stack" case

  T min() const
  {
    return stack.empty() ? inf : stack.top().second;
  }

  T top() const
  {
    // UB if stack empty
    return stack.top().first;
  }

  void push(const T& value)
  {
    auto old_min = min();
    auto new_min = std::min(old_min, value);
    stack.emplace(value, new_min);
  }

  void pop()
  {
    stack.pop();
  }
};
```

## Правильная скобочная последовательность

**Определение**: **правильной** скобочной последовательностью (ПСП) называют последовательность скобок `(` и `)`, между которыми можно вставить символы `1` и `+`, чтобы получилось корректное математическое выражение.

В общем случае скобки не обязаны быть `(` и `)`.

### Задача 1

**Условие**: дана ПСП длины $2 \cdot N$. Для каждой открывающей скобки `(` вычислить позицию соответствующей закрывающей скобки `)`.

**Идея**: Будем обрабатывать последовательность слева направо (по возрастанию индексов).

Рассмотрим две открывающие скобки, для которых мы еще не встретили соответствующие им закрывающие скобки.

Если мы встретим закрывающую - то какой открывающей она будет соответствовать? Той, которую встретили позже.

Соответственно, мы опять получили принцип LIFO: чем позже мы встретили открывающую скобку, тем раньше она получит соответствующую закрывающую.

**Решение**: Будем обрабатывать последовательность слева направо (по возрастанию индексов).

Если встречаем открывающую скобку - кладём её позицию на вершину стека. Назовём такие скобки "ожидающими".

Если встречаем закрывающую скобку - извлекаем с вершины стека позицию последней "ожидающей" скобки, после чего записываем в ответ соответствующую пару.

#### Пример реализации

```cpp
auto get_ans = [&](const std::string& brackets)
{
  std::stack<size_t> waiting_open;
  std::vector<size_t> answer(brackets.size(), -1);

  const char OPEN = '(', CLOSE = ')';

  for (size_t i = 0; i < brackets.size(); ++i)
  {
    char bracket = brackets[i];
    if (OPEN == bracket) waiting_open.push(i);
    else
    {
      size_t open_i = waiting_open.top();
      waiting_open.pop();

      answer[open_i] = i;
    }
  }

  return ans;
};
```

### Задача 2

**Условие**: Дана строка $S$ из $N$ символов. Проверить, что она является ПСП.

**Идея**:

- Рассмотрим алгоритм поиска парных скобок из задачи 1.
- Если мы встречаем закрывающую скобку при пустом стеке - последовательность не является ПСП.
  - Причем неважно, встретим мы далее открывающую скобку или нет.
- Если в конце стек не пустой - последовательность не является ПСП.

- Можно заметить, что в данном случае нас не интересует сам стек, но только его размер.
- Целая величина, равная размеру "виртуального" стека в задачах на ПСП называется **балансом**.
  - Одно из определений ПСП звучит как "все префикс-балансы неотрицательны, итоговый баланс равен 0".

**Решение**:

```cpp
auto get_ans = [&](const std::string& brackets)
{
  const char OPEN = '(', CLOSE = ')';

  int balance = 0;

  for (size_t i = 0; i < brackets.size(); ++i)
  {
    char bracket = brackets[i];
    if (OPEN == bracket) balance++;
    else
    {
      if (balance == 0) return false;
      --balance;
    }
  }

  if (balance != 0) return false;

  return true;
};
```

## Ближайший меньший

### Задача

**Условие**: дан массив $A$ длины $n$. Для каждого элемента найти позицию ближайшего "слева" элемента, меньшего данного.

Формально: вычислить массив $L_i$:

- $L_i < i$.
- $A_{L_i} \le i$.
- Все элементы на интервале $(L_i, i)$ строго больше $a_i$.

**Лемма**:

- Рассмотрим два элемента $a_j \ge a_i$ $(j < i)$.
- Для всех элементов $k > i$ верно:
  - Либо $a_k < a_i$ - тогда оба элемента $(a_j, a_i)$ не могут быть ответом.
  - Либо элемент $a_i$ может быть ответом, но $a_j$ точно нет.

**Основа идеи**:

- Рассмотрим два элемента $a_j \le a_i$ $(j < i)$.
- Для всех элементов $k > i$ верно:
  - Либо $a_k \ge a_i$ - тогда элемент $a_i$ может быть ответом, но не $a_j$.
  - Либо $a_k < a_i$ - тогда $a_i$ не может быть более ответом (исходя из леммы), но $a_j$ еще может быть ответом.

- Видим принцип LIFO - элемент $a_i$ был обработан позже, но перестанет быть "кандидатом на ответ" ранее.

**Итоговая идея**

- Идем "слева направо" по элементам.
- Поддерживаем стек "кандидатов на ответ".
  - Храним пары (значение, индекс).
  - Мы знаем, что элементы в стеке хранятся в порядке **возрастания**.
- Для текущего элемента $a_i$ выкидываем с вершины стека элементы, пока они строго больше.
- Записываем в ответ позицию на вершине стека.
- Кладем пару $(a_i, i)$ на вершину стека и переходим к следующему элементу.

**Решение**:

```cpp
auto get_ans = [&](const std::vector<int>& a)
{
  size_t n = a.size();

  int no_pos = -1;
  std::vector<int> left_le(n, no_pos);

  int neg_inf = *std::min_element(a.begin(), a.end()) - 1;

  using info_t = std::pair<int, int>;
  std::stack<info_t> candidates = { {neg_inf, no_pos } };

  for (size_t i = 0; i < brackets.size(); ++i)
  {
    int cur = a[i];
    while (candidates.top().first > cur) candidates.pop();

    left_le[i] = candidates.top().second;
    candidates.emplace(cur, i);
  }

  return left_le;
};
```