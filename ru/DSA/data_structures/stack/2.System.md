**Примечание**: описание в этой части статьи является упрощенным и содержит лишь самые общие концепции, позволяющие лучше понять связь со структурой "стек".

# Stack overflow - what stack?!

Хорошо, вы узнали, что есть абстракция / подход к использованию под названием "стек".

Но в таком случае что значит ошибка "stack overflow"? Ошибка настолько популярна, что даже дала название [одноименному сайту](https://stackoverflow.com/)

Вероятно вы хотя бы один раз получали данную ошибку:

- при слишком глубокой (часто бесконечной) рекурсии;
- при попытке выделить **большой** статический массив внутри `main` (специфично для С++).

Но где тут стек?

## Системный стек - область памяти

Любому процессу выделяется определенный объем памяти, разделяемый на несколько областей.

С одной из этой областей вы уже не раз встречались - это динамическая память, с которой вы работали с помощью операторов `new` и `delete`.

Но на самом деле еще ранее вы познакомились с меньшей по размеру, но не менее важной областью памяти - **системным стеком**.

Важно отметить, что по умолчанию системный стек процесса зачастую заметно меньше динамической памяти.

В системном стеке обычно хранится два вида значений:

- все локальные переменные, не хранимые явно в динамической памяти.
- параметры вызываемой функции и информация, необходимая для возврата.

Думаю, уже становится понятно, почему "stack overflow" возникал чаще всего именно при описанных выше случаях.

Но почему данная область памяти называется системным **стеком**? Где в ней реализуются операции `push` / `pop`?

### Локальные переменные и стек

Рассмотрим жизненный цикл какой-либо локальной переменной:

- начинается область видимости, в рамках которой переменная существует (например, блок `{ }`).
- происходят все необходимые действия с переменной.
- область видимости заканчивается, переменная очищается.

Легко заметить, что если одна область видимости **вложена** в другую, то переменные во вложенной области будут очищены ранее, чем переменные во внешней - налицо реализация принципа LIFO.

### Рекурсия и стек

Пусть вы находитесь в функции $F$, из которой вы вызываете функцию $G$.

В таком случае на системный стек кладутся:

- значения локальных переменных функции $F$;
- мета-информация о том, "куда вернуться" после возврата из $G$;
- (при вызове $G$) значения параметров для вызова функции $G$.
- (при возврате из $G$) результат вычисления (если таковой присутствует).

Первые два пункта обычно объединяют в понятие "фрейм активации" - он будет удален из стека при возврате из функции $G$, а до того будет занимать часть памяти.

Допустим, что внутри $G$ был произведен еще один вызов функции (обозначим вызванную функцию через $H$).

В таком случае при возврате из рекурсии сначала будет удален и обработан именно фрейм активации функции $G$ (который положили позже), а только потом фрейм функции $F$ - опять мы сталкиваемся с принципом LIFO при работе с данными в системном стеком.

### Выбрасывание исключений

Вероятнее всего, вы хотя бы раз писали программу, которая выбрасывала какое-то исключение в процессе.

Если вы не ловили исключение, то могли увидеть на экране точное место возникновения ошибки.

Зачастую место ошибки отображается в виде **stacktrace** - набора пар (имя функции, номер строки).

По сути данный stacktrace представляет собой версию стека рекурсии на момент возникновения исключения.

#### Построение логики на основе исключений

Как вы знаете, при выбрасывании исключения выполнение текущей функции резко останавливается, после чего начинается резкий подъём вверх по стеку рекурсии вплоть до `try-catch` блока.

Данный механизм может показаться очень удобным для быстрого возврата из рекурсии даже вне исключительных ситуаций.

НЕТ, это плохая практика кода:

- выброс исключения - дорогая операция;
- код становится сложно отлаживать.
- некоторые механизмы и оптимизации компилятора не работают с исключениями (но работают с `return`).