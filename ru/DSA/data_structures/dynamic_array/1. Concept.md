# Динамический массив

Простейшая динамическая структура данных - массив с возможностью добавления / удаления элементов (и, соответственно, изменения собственного размера).

Давайте рассмотрим подходы к эффективной реализации такой структуры.

## Важные операции

Для начала зафиксируем, какие операции мы хотим выполнять **эффективно**:

- получать значение **по индексу**.
- добавить элемент **в конец массива**;
- удалить элемент **из конца массива**.

В идеале две эти операции должны выполняться за $O(1)$ (хотя бы _амортизированно_).

Да, наш массив еще должен уметь вставлять / удалять значения **из произвольной позиции**, но на это уже не накладывается явных требований по эффективности.

## Реализация на массиве

В простейшем варианте динамический массив строится на основе **массива с фиксированным размером**.

Введём обозначения:

- $S$ (size) - размер динамического массива как структуры для внешнего пользователя;
- $C$ (capacity) - фиксированный размер внутреннего массива.

В таком случае общая логика _важных операций_ выражается довольно просто:

- при получении элемента по индексу:
  - просто обращаемся к заданному индексу во внутреннем массиве за $O(1)$.
- при добавлении элемента:
  - если $S = C$, то внутренний массив расширяется;
    - выделяется память под новый массив;
    - все элементы перемещаются в новый массив.
  - если добавление в позицию $P$: суффикс массива сдвигается за $O(S - P)$;
  - новый элемент просто встаёт на искомую позицию за $O(1)$.
- при удалении элемента:
  - если удаление из позиции $P$: суффикс массива сдвигается за $O(S - P)$;
  - (опционально) при выполнении некоторых условий может производиться уменьшение внутреннего массива для экономии памяти.

Очевидно, что единственная "тяжелая" операция - это расширение внутреннего массива. Рассмотрим два подхода к реализации данной части функционала.

### Аддитивный подход

В этом случае массив расширяется на дополнительные $D$ ячеек ($D$ фиксировано).

Без потери общности будем считать, что $N = D \cdot K + 1$ и мы начинаем с пустого массива.

В таком случае суммарно при **добавлении элемента в конец** будет сделано $T(D, K) = D + 2 \cdot D + \dots + K \cdot D$ перемещений элементов.

По формуле арифметической прогрессии $T(D, K) = \frac{(K + 1) \cdot K \cdot D}{2} \sim \frac{K^2 \cdot D}{2}$.

Учитывая, что $K = \frac{N}{D}$, получаем $T(N, D) = O(\frac{N^2}{D})$.

Откуда амортизированная сложность добавления элемента получается равной $O(\frac{N}{D})$ - линейная от $N$, но стремящаяся к константе при стремлении $D$ к $N$:

- либо $D$ слишком мало и перемещений слишком много;
- либо $D$ достаточно велико, вследствие чего может выделяться много лишней памяти.

### Мультипликативный способ

Давайте попробуем расширять массив, умножая текущий размер на вещественный коэффициент $W = (\lambda + 1)$:

- при $\lambda = 1$ получаем умножение прежнего размера в $2$ раза.

Без потери общности будем считать, что $N = W^K + 1$ и мы начинаем с массива размером $1$.

В таком случае суммарно при **добавлении элемента в конец** будет сделано $T(W, K) = (W^0 + W^1 + \dots + W^K)$ перемещений элементов.

По формуле геометрической прогрессии $T(W, K) = \frac{W^{K + 1} - 1}{W - 1} \sim \frac{W^{K + 1}}{\lambda}$.

Учитывая, что $W^K \sim N$, получаем $T(N, \lambda) \sim \frac{N \cdot (\lambda + 1)}{\lambda} = N + \frac{N}{\lambda}$.

Откуда амортизированная сложность добавления элемента получается равной $O(1 + \frac{1}{\lambda})$ - константная при фиксированной $\lambda$:

- при $\lambda = 1$ получаем _в среднем_ $2$ операции перемещения на элемент.

Обратите внимание, что при повышении $\lambda$ количество операций перемещения будет снижаться, но аналогично случаю большого $D$ будет увеличиваться размер "лишней" выделенной памяти.
