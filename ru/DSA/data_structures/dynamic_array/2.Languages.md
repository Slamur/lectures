## C++

В С++ динамический массив представлен классом `std::vector<T, Allocator>` со следующим набором операций:

- `size` - получить количество элементов в структуре.

- `constructor` - создать пустой вектор с заданным размером и (опционально) заполнить ячейки одним и тем же значением;

- `reserve` - установить "capacity" внутреннего массива (не изменяет "size").
- `resize` - изменить количество ячеек на заданное и (опционально) заполнить ячейки одним и тем же значением.
- `assign` - сделать количество ячеек равным заданному и присвоить каждой ячейке одно и то же заданное значение / значения из последовательности.

- `operator[]` и `at` - получить / изменить элемент по индексу.

- `push_back` - добавить значение в конец (происходит копирование);
- `emplace_back` - создать в конце значение по заданному набору параметров (без копирования);
- `back` - получить значение последнего элемента;
- `pop_back` - удалить последний элемент (ничего не возвращает);

- `front` - получить значение первого элемента.

- `insert` - вставить значение перед заданным **итератором**.
- `erase` - удалить элемент, заданный **итератором**.

- `begin` / `end` - получить итераторы последовательности.

### Вспомогательные функции

Для `std::vector` доступны все стандартные функции для последовательностей.

Также `std::vector` можно отсортировать с помощью операции `std::sort` (работает за $O(N \cdot \log{N})$).

### Итераторы и память

Стандарт гарантирует, что данные в векторе хранятся последовательно в памяти (аналогично обычно массиву).

Поэтому итераторы вектора часто используются аналогично указателям на элемент в обычном массиве.

Но **надо помнить** - при перемещении элементов в новый массив итераторы **инвалидируются**:

```cpp
std::vector<int> a = {1, 2, 3};

for (int it = 0; it < 5; ++it)
{
  auto& it = a.begin();
  a.push_back(*it);
  // possibly invalid iterator
  std::cout << *it << std::endl;
}
```

### vector и string

Вы могли заметить, что `std::string` в С++ ведут себя аналогично `std::vector`. И это не просто совпадение.

На самом деле у этих классов есть общий класс-предок `std::basic_string`, реализующий основные аспекты "динамического массива на массиве".

## Java

В Java доступен интерфейс динамического массива `List<T>` (описывает ожидаемый набор операций без деталей реализации):

- `size` - получить количество элементов в структуре.
- `constructor` - возможно указать начальное значение параметра $C$ (но размер всегда будет $0$).
- `get` и `set` - получить / изменить элемент по индексу.
- `add` - добавить значение в конец / в заданную позицию;
- `remove` - удалить заданное значение / значение из заданной позиции (возвращается удаленное значение);
- `indexOf` / `lastIndexOf` - найти первую / последнюю позицию заданного значения;
- `iterator` - получить итератор.

Реализация на основе массива представлена классом `ArrayList<T>` (название явно намекает).

### Выделение памяти

- При малых значениях $C$ параметр $\lambda$ равен $1$ (размер увеличивается в $2$ раза).

- При значениях $C \ge 64$ параметр $\lambda$ становится равным $0.5$ (размер начинает увеличиваться в $1.5$ раза).

### Полезные функции

Java предоставляет набор вспомогательных функций для работы с `List` в классе `Collections`, например:

- `asList` - преобразовать набор значений / массив в **иммутабельный** `List`.
- `reverse` - изменить порядок элементов на противоположный для заданного `List`.
- `sort` - отсортировать заданный `List` (за $O(N \cdot \log{N})).

### ArrayList и String

В отличие от C++, `String` в Java является иммутабельной, поэтому реализация у них достаточно разная.

В то же время есть схожий по функционалу строковый класс `StringBuilder`, предназначенный специально для множественных модификаций строки.

## Python

Динамический массив представлен классом `list` (`[]`) со следующим функционалом:

- `len` - получить количество элементов в структуре.
- `operator []` - получить / изменить элемент по индексу.
- `append` - добавить значение в конец;
- `extend` - добавить последовательность в конец;
- `remove` - удалить первое вхождение значения;
- `pop` -  удалить значение из заданной позиции (по умолчанию последний элемент);
- `index` / `count` - найти первую позицию / количество элементов с заданным значением;
- `sort` - отсортировать по возрастанию / убыванию (ничего не возвращает) - работает за $O(N \cdot \log{N})$.
- `reverse` - изменить порядок элементов на противоположный (ничего не возвращает).
- `__iter__` - получить итератор.

### Срезы

Python поддерживает синтаксис **срезов** для `list` и `str` - получение подмассива по заданному полуинтервалу индексов:

```py
a = [2, 4, 1, 5, 3]
b = a[2:4] # b = [1, 5]
```

### Вспомогательные функции

- `sorted` - получение сортированной копии любой последовательности в виде объекта типа `list`.
