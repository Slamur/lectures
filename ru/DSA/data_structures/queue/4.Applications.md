# Applications

## Indexing

### Задача

**Условие**: Поддержать в очереди операцию `get(index)` за $O(1)$ (нумерация от первого элемента очереди).

**Решение**: использование динамического массива автоматически добавляет такую возможность без дополнительных модификаций.

## Multipop

### Задача

**Условие**: Поддержать в очереди операцию `multipop(k)` за $O(k)$ - извлечь из очереди $k$ первых значений.

Оценить **амортизированную сложность** данной операции.

**Решение**: всё полностью аналогично стеку.

## Minimum in queue

### Задача

**Условие**: поддержать в очереди операцию `min()` за $O(1)$ - минимальное значение среди лежащих внутри очереди.

**Решение 1**:

- реализуем очередь на основе двух **стеков на минимум**.
- выберем меньший из минимумов каждого стека.

**Идея 2**:

- рассмотрим значения $v_1 \ge v_2$ такие, что $v_1$ вставлен в очередь раньше, чем $v_2$.
- в таком случае после вставки $v_1$ уже никогда не будет являться **кандидатом на ответ**, так как удалится раньше $v_2$.
  - такой $v_1$ можно не хранить явно в очереди.

**Решение 2**:

- используем deque (нам понадобится операция `pop_back`).
- храним пары (`value`, `push_index`) - значение и номер запроса вставки.
  - также поддерживаем величины `push_cnt` и `pop_cnt` - количество выполненных запросов вставки и извлечения соответственно.
- допустим, мы вставляем значение $v$ в конец очереди.
  - пока в конце deque лежит значение большее $v$ - извлекаем его через `pop_back`.
  - добавляем в конец пару ($v$, `push_cnt`) и увеличиваем `push_cnt` на $1$.
- при запросе извлечения:
  - сравниваем номер запроса вставки у начального элемента с `pop_cnt`.
  - если номера совпадают - физически извлекаем элемент.
  - в любом случае увеличиваем `pop_cnt`.
- запрос минимума выполняется за $O(1)$ - в описанной реализации первый элемент всегда минимальный.

#### Пример реализации (для 2)

```cpp
template<typename T>
struct MinimumQueue
{
  using info_t = std::pair<T, size_t>;

  std::deque<info_t> deque;
  size_t push_cnt, pop_cnt;

  T min() const
  {
    // UB if queue is empty
    return deque.front().first;
  }

  // we can't do top() queries now

  void push(const T& value)
  {
    while (!deque.empty() && deque.back().first >= value) deque.pop_back();
    deque.emplace_back(value, push_cnt);
    ++push_cnt;
  }

  void pop()
  {
    // UB if queue is empty
    if (deque.front().second == pop_cnt) deque.pop_front();
    ++pop_cnt;
  }
};
```

##  Вставка в фиксированную позицию K

### Задача

**Условие**:

- дано $Q$ запросов трёх видов:
  - вставить значение в **конец** очереди;
  - вставить значение в очередь $k$-м от начала.
    - **важно**: $k$ одинаково для всех запросов (известно заранее).
  - посмотреть / удалить значение в начале очереди.

**Решение**:

Будем хранить первые $k$ элементов в головной deque `head`, а все остальные - в хвостовой deque `tail`:

- вставка в конец - просто `push_back` в `tail`
  - если `head` содержит меньше $k$ значений - то `push_back` в `head`;
- вставка $k$-м от начала:
  - если `head` содержит ровно $k$ значений - перекинуть последний элемент из `head` в начало `tail`.
  - `push_back` в `head`;
- просмотр значения в начале - `front` в `head`.
- извлечение из начала:
  - `pop` из `head`;
  - перекинуть первый элемент из `tail` в конец `head`.

#### Пример реализации

```cpp
template<typename T>
struct QueuePushK
{
  size_t k;
  std::deque<T> head;
  std::deque<T> tail;

  QueuePushK(size_t k)
  : k(k)
  { }

  bool empty() { return head.empty(); }

  void push(const T& value)
  {
    if (head.size() < k) head.push_back(value);
    else tail.push_back(value);
  }

  void push_k(const T& value)
  {
    if (head.size() == k) {
      tail.push_front(head.back());
      head.pop_back();
    }

    head.push_back(value);
  }

  T front()
  {
    // UB if queue is empty
    return head.front();
  }

  void pop()
  {
    head.pop_front();

    if (!tail.empty())
    {
      head.push_back(tail.front());
      tail.pop_front();
    }
  }
};
```