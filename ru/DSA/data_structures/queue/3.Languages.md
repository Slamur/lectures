# C++

## `std::queue`

Аналогично `std::stack` является классом-обёрткой c операциями:

- `back` и `front`;
- `push`;
- `pop`.

Контейнер (шаблонный параметр `Container`) должен реализовывать операции:

- `back`;
- `push_back`;
- `front`;
- `pop_front`.

Основными кандидатами для `std::queue` являются:

- `std::deque` - вариант по умолчанию;
- `std::list`.

## `std::deque`

Хотя это не совсем очевидно, но `std::deque` в С++ реализован на основе **блочного принципа** - и, соответственно, занимает в различных аспектах промежуточное положение между `std::vector` и `std::list`.

### Инвалидация итераторов / указателей

Гарантируется, что вставка в начало/конец `std::deque` не инвалидирует указатели на остальные хранящиеся элементы.

### Потребление памяти

Из-за блочной структуры `std::deque` даже для одного элемента вынуждена хранить целый блок фиксированного размера.

Это может приводить к неожиданным эффектам, особенно при хранении множества `std::deque`, каждая из которых хранит небольшое количество элементов.

Приведу цитату из документации C++: `On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).`

### Индексация

Из-за блочной реализации на основе динамического массива, `std::deque` может также эффективно выполнять запросы **индексации**.

В отличие от `std::vector`, где индексация выполняется за одно разыменование указателя, `std::deque` использует два разыменования - переход к блоку и обращение к элементу в блоке.

### Вставка / удаление из заданной позиции

На всякий случай уточню, что `std::deque` не умеет эффективно вставлять / удалять значения из заданной позиции (аналогично `std::vector`).

# Java

Java предоставляет два интерфейса `Queue` и `Deque` соответственно:

- `poll` / `pollLast` и `pollFirst` для вставки;
- `peek` / `peekLast` и `peekFirst` для доступа;
- `poll` / `pollLast` и `pollFirst` для извлечения.

Также `Deque` содержит методы `push` и `pop` для эмуляции работы со стеком - по сути они перенаправляются в описанные выше методы.

В качестве реализации рекомендуется использовать класс `ArrayDeque` - внутри находится стандартный **циклический буфер**.

# Python

Пакет `collections` содержит структуру `deque` с базовыми операциями:

- `appendleft` и `append` для вставки в начало и конец соответственно;
- `popleft` и `pop` для удаления из начала и конца соответственно;
- `[9]` и `[-1]` (операторы индексации) для доступа к первому и последнему элементам.