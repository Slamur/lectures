# Динамическое управление памятью

Большинство структур данных являются **динамическими** - то есть изменяют свой размер в процессе. Это приводит к необходимости динамического выделения и очистки памяти - как для массивов, так и для служебных структур и классов.

## New и delete

### New

Самый базовый способ выделения памяти - использование оператора `new`. 

Обычно он выполняет сразу две функции:

- делает запрос на выделение нужного количества динамической памяти;
- вызывает конструктор соответствующего типа.

#### C++

В С++ `new` чаще всего реализован через вызов `malloc` в виде двух отдельных операторов:

- `operator new(size_type)` для выделения памяти под одно значение;
- `operator new[](size_type)` для выделения памяти под массив значений.

Данные операторы можно перегрузить, но только для всего кода сразу.

### Delete

#### C++

В С++ разработчик должен самостоятельно очищать память, выделенную оператором `new`, используя оператор `delete`. 

Обычно `delete` выполняет две функции (аналогично `new`):

- вызывает деструктор;
- освобождает память.

Чаще всего `delete` реализован через вызов `free` в виде аналогичных операторов (для одного значения и массива).

По аналогии с `new` данные операторы можно перегрузить, но только для всего кода сразу.

#### Java и Python

В этих языках разработчик не должен самостоятельно очищать память. Вместо этого происходит автоматическая очистка памяти с помощью **сборщиков мусора**.

Основная проблема такого подхода в невозможности напрямую управлять тем, когда и что будет убрано. Можно "запрашивать" очистку, но нет гарантии, что она случится прямо сейчас.

В самом простом случае сборщик мусора ведет учет количества ссылок на участок памяти - когда счетчик достигает 0, память помечается под очистку. Но современные сборщики мусора реализованы через множество эвристик для более эффективной работы всей программы.

## Allocator

Вы могли заметить, что у `new` / `delete` есть два неудобства:

- они сразу вызывают конструктор;
- их нельзя переопределить только для определенного класса.

Поэтому при создании `std`-структур данных было предложено сделать параметр шаблона `Allocator`.

По сути идея **аллокатора** - инкапсулировать в себе выделение и очистку памяти (обратите внимание, без вызова конструктора / деструктора).

Плюс для разных структур данных можно определить различные аллокаторы, что даёт большую свободу действий.

### std::allocator

С++ предоставляет стандартный аллокатор `std::allocator`:

- только выделяет / очищает память для заданного шаблоном типа;
- не содержит никаких полей (т.н. _stateless_).

При желании его можно наследовать (если хочется немного расширить функционал), но можно и описать собственный аллокатор полностью с нуля.

### Tags

По аналогии с итераторами, от класса аллокатора ожидается наличие нескольких тегов, например:

- `value_type`;
- `size_type`;
- `difference_type`.

### Allocator traits

До C++ 20 аллокаторы обладали расширенным набором функций, например:

- `construct` - создать объект с заданным набором параметров;
- `destroy` - разрушить объект.

Но в современных версиях C++ этот функционал (как и часть тегов) перенесли в `std::allocator_traits<AllocType>`.

По сути это позволило сделать аллокаторы максимально простыми и "чистыми", выполняющими **ровно одну** функцию.

### Rebind

Многие структуры данных в С++ могут использовать аллокаторы не напрямую для хранимого типа значений.

Поэтому они ожидают от используемого класса аллокатора наличие шаблонного конструктора

```cpp
// allocator has type T

template<typename U>
allocator_class(const allocator_class<U>& other)
{
  // initialize by other
}
```

Таким образом они могут создать нужный им аллокатор на основе переданного в шаблоне.