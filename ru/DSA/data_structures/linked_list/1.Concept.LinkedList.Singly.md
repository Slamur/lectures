# Singly linked list

Представьте себе ситуацию: вы пришли в поликлинику к врачу, а приём в порядке живой очереди.

Что вы сделаете?

- спросите "Кто последний?";
- запомните ответивших;
- не будете сводить с них глаз, так как они являются вашей **единственной связью** с очередью;
  - возможно за вами придут еще люди - и тогда вы станете такой же связью для кого-то ещё.

В этот момент вы станете **узлом** в структуре под названием "**односвязный список**".

## Узлы и связи

Односвязный список можно представить как набор **узлов**, каждый из которых обладает двумя атрибутами:

- `value` - значение (информация), которое хранится в узле;
- `next` - указатель на следующий узел в списке (либо `nullptr`, если следующего нет).

Простейший узел может быть описан следующей структурой:

```cpp
template<classname T>
struct Node
{
  T value;
  Node<T>* next;
};
```

Сам список в таком случае задаётся указателем на первый узел.

```cpp
template<classname T>
class SinglyLinkedList
{
public:
  using node_t = Node<T>*;
private:
  node_t first_node;
};
```

## Операции и итераторы

Любую структуру можно описать через проводимые над ней операции и дополнительные гарантии.

Давайте опишем простейшие виды операций, которые можно производить с односвязным списком.

Как и в случае с динамическим массивом, большинство операций будут производится через **итераторы**.

### Итераторы `begin` / `end`

В простейшем случае узлы могут сами выполнять роль итераторов, так как отвечают двум простейшим принципам:

- получение ассоциированного значения;
- переход к следующему итератору.

В данной лекции мы будем придерживаться данной политики (узел == итератор) для простоты объяснения.

```cpp
class SinglyLinkedList
{
public:
  using iterator_t = node_t;
  iterator_t begin();
  iterator_t end();
};
```

#### Но ведь `end` лежит "после списка"?

Одним из способов реализации `end`-парадигмы является введение указателя на фиктивный `end`-узел.

Правда в большинстве ситуаций нет смысла делать данный узел чем-то иным, кроме `nullptr`.

```cpp
class SinglyLinkedList
{
public:
  SinglyLinkedList();
private:
  node_t _begin;
  node_t _end;
};

SinglyLinkedList::iterator_t SinglyLinkedList::begin()
{
  return _begin;
}

SinglyLinkedList::iterator_t SinglyLinkedList::end()
{
  return _end;
}
```

В таком случае конструктор списка может выглядеть следующим образом:

```cpp
SinglyLinkedList::SinglyLinkedList()
{
  _end = nullptr; // you can create some fictive Node { default(T), nullptr } if you want
  _begin = _end; // because right now we don't have any nodes in the list
};
```

#### Непосредственно итерация

Единственным заметным отличием можно считать замену оператора `++` на явный переход по указателю `next`:

```cpp
for (auto it = begin; it != end; it = it->next)
{
  // do some stuff with it->value
}
```

#### Разделение узлов и итераторов

Очевидно, что использование узлов напрямую в качестве итераторов удобно только в простейших задачах.

В ином случае происходит добавление отдельной структуры итератора, хранящей внутри себя указатель на текущий узел.

```cpp
struct Iterator
{
  node_t current_node;

  T& operator*() { return current_node->value; }
  Iterator& operator++() { node = node->next; return *this; }
};
```

## Вычисление количества элементов `size`

В простейшем случае вычисление `size` происходит за $O(N)$ итерацией от `begin` к `end`.

Очевидной оптимизацией является хранение дополнительного атрибута `size` в классе списка.

```cpp
class SinglyLinkedList
{
public:
  size_t size() const { return _size; }
private:
  size_t _size;
};
```

## Поиск итератора с заданным значением

В простейшем варианте возможен только линейный поиск за $O(N)$ (как и в случае с массивом / динамическим массивом).

### Все значения списка уникальны

В этом случае можно построить **словарь**:

- **ключ** - информация (значение), хранящееся в узле;
- **значение** - соответствующий узел.

Такой подход позволяет выполнять поиск узла за $O(get)$, где $get$ - стоимость операции поиска в словаре.

## Поиск итератора по индексу

В отличие от массива итераторы связного списка не являются "Random access", а значит индексация возможна только за $O(index)$.

```cpp
SinglyLinkedList::iterator_t SinglyLinkedList::at(size_t need_pos)
{
  // any need_pos validation

  auto it = begin();
  for (size_t pos = 0; pos < need_pos; pos++, it = it->next);

  return it;
};
```

## Вставка узла до и после итератора

### Вставка ПОСЛЕ итератора

Пусть у нас есть узел `before`, **после** которого необходимо вставить новый узел `node`.

В таком случае требуется выполнить $O(1)$ действий:

- создаем связь "next -> after";
- создаём связь "before -> next".

```cpp
class SinglyLinkedList
{
private:
  void _place_after(node_t before, node_t node)
  {
    auto after = node->next;
    node->next = after;
    before->next = node;
  }
};
```

### Вставка ДО итератора

Единственный способ в условиях односвязного списка - произвести линейный поиск **предыдущего** узла, относительно которого произвести вставку "после" - получаем $O(index)$ действий на вставку.

## Вставка узла в самое начало

Вставка узла в начало (перед `begin`) является специальным случаем:

- нет узла "до";
- необходимо обновить значение поля `begin`.

```cpp
class SinglyLinkedList
{
private:
  void _place_first(node_t node)
  {
    node->next = _begin;
    _begin = node;
  }
};
```

### Головной узел `head`

Вместо реализации отдельного метода для вставки узла в начало можно просто сделать узел "до `begin`" - его обычно называют `head`.

Указатель на `head` не может быть `nullptr`, в отличие от указателя на `end` - но хранимое в `head` значение нигде не используется.

```cpp
class SinglyLinkedList
{
public:
  SinglyLinkedList();
private:
  node_t _head;
};

SinglyLinkedList::iterator_t SinglyLinkedList::begin()
{
  return _head->next;
}

SinglyLinkedList::SinglyLinkedList()
{
  _head = new Node { default(T), _end };
};
```

Обратите внимание, что при такой реализации необходимость в `place_first` отпадает сама собой:

- для `begin` также существует итератор "до";
- вместо отдельного поля `_begin` мы меняем атрибут `next` в узле `head`, что обрабатывается общим случаем.

В дальнейшем мы будем подразумевать, что список написан через `head`-парадигму.

## Вставка узла в конец списка

Важно понимать, что "вставить в конец списка" означает "вставить **перед** `end`".

Поэтому в описанной выше реализации данный процесс будет выполняться за $O(size)$.

Чтобы избежать лишних действий, можно хранить дополнительное поле списка `last`, указывающее на узел "перед `end`".

Очевидно, что в пустом списке `last` соответствует `head`.

```cpp
class SinglyLinkedList
{
private:
  node_t _last;

  void _place_last(node_t node)
  {
    _place_after(_last, node);
    _last = node;
  }
};

SinglyLinkedList::SinglyLinkedList()
{
  _last = _head;
};
```

## Добавление значения в список

Данный процесс состоит из трёх шагов:

- создать новый узел с добавляемым значением.
- найти узел/итератор, после которого значение вставляется.
- осуществить вставку узла (см. пункт выше).

Очевидно, что единственной потенциально дорогой операцией является **поиск итератора**, так как остальные операции выполняются за $O(1)$.

```cpp
void SinglyLinkedList::insert_after(SinglyLinkedList::iterator_t before, const T& value)
{
  node_t node = new Node { value, nullptr };
  _place_after(before, node);

  _size++;
}
```

### В начало / конец списка

В данном случае вставка идёт после узлов `head` и `last`.

Так как список хранит явно указатели на эти узлы, то поиск осуществляется за $O(1)$.

### В заданную позицию списка

В этом случае поиск узла / итератора осуществляется за $O(index)$ линейным проходом, начиная с `begin`.

## Извлечение узла до/после итератора

### Извлечение узла после итератора

Пусть у нас есть узел `before`, **после** которого необходимо извлечь узел.

В таком случае требуется выполнить всего одно действие - создать связь "before -> after".

```cpp
class SinglyLinkedList
{
private:
  node_t _extract_after(node_t before)
  {
    auto node = before->next;
    auto after = node->next;
    before->next = after;
    return node;
  }
};
```

### Извлечение узла до итератора

Аналогично "вставке до итератора" единственный способ для односвязного списка - за $O(index)$ найти итератор "до", после чего выполнить описанные выше действия.

## Извлечение узла из начала / конца списка

### Извлечение из начала

Данная операция не представляет каких-то трудностей и выполняется за $O(1)$, независимо от того, используется `head` или нет.

### Извлечение из конца

С другой стороны, для удаления из конца вам придётся найти узел "перед `last`", что возможно сделать только за $O(size)$.

И не забудьте обновить поле `_last` списка (если вы его используете).

## Удаление значения из списка

В отличие от динамического массива, для удаления значения из односвязного списка нам необходим итератор "перед" нашим значением (по причинам, описанным выше).

Общая логика процесса схожа с вставкой:

- находим итератор "перед" значением;
- извлекаем узел, соответствующий значению;
- **удаляем** узел оператором `delete`.

```cpp
void SinglyLinkedList::erase_after(SinglyLinkedList::iterator_t before)
{
  auto node = _extract_after(before);
  delete node;

  _size--;
}
```

Аналогично добавлению, сложность операции полностью зависит от сложности поиска соответствующего итератора:

- из начала - $O(1)$;
- из конца - $O(size)$;
- из заданной позиции - $O(index)$.