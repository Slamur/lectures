# Questions

- В чем преимущества и недостатки двусвязного списка по сравнению с односвязным?
- Какие операции связный список (односвязный / двусвязный) выполняет более / менее эффективно по сравнению с динамическим массивом?

# Advanced questions

- Допустим вам необходимы только операции `push_back` и `pop_back`. Что эффективнее использовать в большинстве случаев - связный список или динамический массив? Почему?

- Для связного списка часто рассматривают использование аллокатора на **основе статического массива**. Подобный аллокатор, в том числе, позволяет использовать **индексы массива** вместо указателей.
  - Как вы реализуете его? Можете предполагать, что будет использовано не более $N$ узлов.
    - Можно ли использовать динамический массив, если вы не знаете ограничения на количество узлов?
    - Подумайте, как можно переиспользовать "удаленные ранее" узлы.
  - В чем преимущества и недостатки использования такого аллокатора по сравнению с аллокатором на **основе динамической памяти**?
  - Предложите способ оптимизации занимаемой узлом двусвязного списка памяти при использовании индексов массива вместо указателей.
    - Вместо `next` и `prev` используйте одно поле `size_t link`.
    - Дополнительно к `head` храните $O(1)$ информации для получения `begin`.

- Предложите способ реализации **словаря на основе связного списка**. В чем его преимущества и недостатки по сравнению со словарём на основе массива?

- Подумайте над реализацией следующих операций над **структурой** односвязного / двусвязного списка:
  - конкатенация двух списков.
  - удаление целого подотрезка списка.
  - переворот списка (аналог `std::reverse`).
  - " $k$-сжатие списка" - оставить в списке только узлы с номерами $k, 2 \cdot k, \dots $.

- Подумайте, как можно реализовать матрицу (двумерный массив) на основе односвязных / двусвязных списков
  - Какие детали реализации легко обобщаются с одномерного случая, а какие отличаются достаточно сильно? .
  - Для каких операций такая реализация будет более эффективной по сравнению с реализацией на массивах?

- Вам дан первый узел односвязного списка. Вы знаете два факта:
  1. в списке не более $N$ узлов;
  2. у каждого узла **гарантированно** есть следующий.

  Упражнения:
  - Докажите, что данный список представляет из себя цепочку, заканчивающуюся циклом.
  - Предложите алгоритм поиска цикла за $O(N^2)$ времени и $O(1)$ дополнительной памяти.
  - Оптимизируйте алгоритм поиска цикла до $O(N)$ времени.
    - Используйте два итератора - один перемещается на `next` (скорость $1$), второй - на `next -> next` (скорость $2$).
    - Вероятно вам потребуется две "фазы" алгоритма.
