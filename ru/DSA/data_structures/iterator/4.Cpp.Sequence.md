# Последовательности в C++

## Основные операции

Любая структура данных в C++, являющаяся последовательностью, реализует следующие две операции:

- `iterator begin()` - итератор на первый элемент последовательности;
- `iterator end()` - итератор, указывающий на фиктивный элемент "после последнего".

Таким образом, всю последовательность можно описать, как **полуинтервал** _[begin; end)_.

Часто могут быть дополнительно определены вариации данных операций:

- `cbegin()` и `cend()` возвращают `const`-версию итераторов (элементы не могут быть изменены);
- `rbegin()` и `rend()` возвращают итераторы для итерации "назад".

### Разыменование end

Обратите внимание, что разыменование `end`-итератор - UB (_undefined behaviour_).

Поэтому всегда проверяйте полученные итераторы на неравенство `end` перед разыменованием.

### Внешние операции

C++ определяет внешние функции-аналоги:

- `begin(container)` / `cbegin(container)` - аналог `.begin()` и `.cbegin()` соответственно;
- `end(container)` / `cend(container)` - аналогично для `.end()` и `.cend()`.

### Массив как последовательность

#### Статический массив

Переменная типа `T array[]` может быть представлена как последовательность с помощью описанных выше **внешних** операций.

Аналогично для класса `std::array<T, size_t N>` (обертки над статическим массивом) уже определены `begin` / `end` - методы.

#### Динамический массив

В то же время переменная `T* array = new T[size]` не может быть представлена как последовательность по простой причине - С++ не может вычислить `end` без явно вычислимого размера массива.

## Итерирование

Простейший способ итерирования по конечной последовательности, описанный нами выше, в С++ будет записан в следующем виде:

```cpp
for (auto& it = seq.begin(); it != seq.end(); ++it)
{
  T& value = *it;
  // process value
}
```

Легко можно увидеть некоторые из рассмотренных выше операций итераторов:

- `operator*()`;
- `operator++()`;
- `friend operator!=(a, b)`.

Очевидно, что это лишь простейший вариант обработки - многие алгоритмы используют другие варианты обхода или дополнительные операторы итераторов.

### Функции для последовательностей в С++

Рассмотрим некоторые полезные функции, описанные в стандартной библиотеке:

- `find` / `find_if` / `find_if_not` - поиск итератора на элемент со значением, равным заданному / удовлетворяющим условию.
- `count` / `count_if` - вычисление количества элементов со значением, равным заданному / удовлетворяющим условию.
- `min_element` / `max_element` / `minmax_element`  - поиск итератора на минимум / максимум / вместе.
- `for_each` - применить заданное действие ко всем элементам последовательности.
- `fill` - присваивание одного и того же значения всем элементам последовательности.
- `accumulate` - left fold (reduce) элементов - по сути поочередное "прибавление" элементов к результату.
- `reverse` - переворот последовательности.
- `copy` / `copy_if` / `copy_backwards` - копирует элементы последовательности в новую.
- `move` / `move_if` / `move_backwards` - аналогично `copy`, но выполняет `move`-операцию к элементам.

Обратите внимание, что поисковые алгоритмы возвращают именно итераторы, а не сами элементы или их позиции:

- если элемент не найден / последовательность пустая, то возвращается `end` - не забудьте проверить результат.
- если нужна позиция элемента (в индексируемых последовательностях) - используйте `std::distance` от `begin`.

### Foreach

В С++ `for-each` реализован в формате

```cpp
for (T& value : sequence)
{
  // process value
}
```