# Теоретические основы сортировок

## Нижняя граница эффективности сортировок через сравнения

Если сортировка основана на сравнениях (отношении порядка), то её эффективность относительно количества сравнений равна $\Omega(N \cdot \log{N})$.

Обратите внимание: это **нижняя** оценка эффективности.

Большинство **встроенных в языки** сортировок имеют сложность $O(N \cdot \log{N})$ в среднем и/или худшем случаях.

### А как же сортировка подсчетом?

Сортировка подсчетом **не использует сравнения** в процессе упорядочивания, так как применяется для типов данных, у которых по умолчанию определено отношения строгого порядка и "следующего значения".

В общем случае сложность сортировки подсчетом равна $O(N + \max{A})$, что накладывает на неё сильные ограничения по использованию.

В то же время если применение сортировки подсчетом возможно - она вполне может быть эффективнее стандартных сортировок, основанных на сравнениях.

## Количество инверсий - мера упорядоченности последовательности

**Инверсией** в последовательности $a$ называют пару $a_i > a_j$ при условии $i < j$.

Если последовательность $a$ отсортирована в порядке отношения $\le$, то количество инверсий равно $0$.

Если последовательность $a$ отсортирована в порядке отношения $\ge$, то количество инверсий равно $C(n, 2)$, где

- $n$ - длина последовательности $a$.
- $C(n, k)$ - биномиальный коэффициент.
  - $C(n, 2) = \frac{n \cdot (n - 1)}{2}$ - фактически каждая пара элементов является инверсией.

# Квадратичные сортировки

В рамках дальнейших описаний считается, что сортируется последовательность $a$ длины $n$ относительно операции $\le$.

## Сортировка пузырьком

- Производится $n - 1$ итерация.
- На $i$-й итерации обрабатываются элементы $a_1, a_2, \dots, a_{n - i}$.
- Если $a_i > a_{i + 1}$, то они меняются местами.

Таким образом поддерживается инвариант - после $i$-й итерации суффикс $a_{n - i + 1} \dots a_n$ является упорядоченным.

Данный процесс очень похож на подъём пузырька в кипящей воде, откуда и появилось название сортировки.

Сложность в худшем случае $O(n + (n - 1) + \dots + 1) = O(n^2)$ сравнений.

Модификацией данной сортировки до $O(n \cdot \log{n})$ является _быстрая сортировка_.

### Реализация

Пример реализации на С++:

```cpp
for (size_t i = 0; i + 1 < n; ++i)
{
  for (size_t j = 0; j + i + 1 < n; ++j)
  {
    if (a[j] > a[j + 1]) std::swap(a[j], a[j + 1]);
  }
}
```

## Сортировка выборкой

- Производится $n - 1$ итерация.
- На $i$-й итерации обрабатываются элементы $a_i \dots a_n$.
- Среди обрабатываемых элементов выбирается **минимальный**, допустим это элемент $a_p$.
- Элементы $a_i$ и $a_p$ меняются местами.

Таким образом поддерживается инвариант - после $i$-й итерации префикс $a_1 \dots a_i$ является упорядоченным.

Сложность в худшем случае $O(n + (n - 1) + \dots + 1) = O(n^2)$ сравнений.

Модификацией данной сортировки до $O(n \cdot \log{n})$ является _сортировка кучей_.

### Реализация

Пример реализации на С++:

```cpp
for (size_t i = 0; i + 1 < n; ++i)
{
  auto it = std::min_element(a.begin() + i, a.end());
  std::swap(a[i], *it);
}
```

## Сортировка вставками

- Производится $n - 1$ итерация.
- На $i$-й итерации обрабатываются элементы $a_1 \dots a_i$.
- Элемент $a_i$ поочередно обменивается с $a_{i - 1}, a_{i - 2}, \dots$ до тех пор, пока префикс $a_1 \dots a_i$ не станет упорядоченным.

Таким образом поддерживается инвариант - после $i$-й итерации префикс $a_1 \dots a_i$ является упорядоченным.

Сложность в худшем случае $O(1 + 2 + \dots + (n - 1) + n) = O(n^2)$ сравнений.

Модификацией данной сортировки до $O(n \cdot \log{n})$ является _сортировка слиянием.

### Реализация

Пример реализации на С++:

```cpp
for (size_t i = 0; i + 1 < n; ++i)
{
  for (size_t j = i; j > 0 && a[j - 1] > a[j]; --j)
  {
    std::swap(a[j - 1], a[j]);
  }
}
```

