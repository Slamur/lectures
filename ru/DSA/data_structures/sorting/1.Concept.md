# Упорядочивание данных

До этого мы изучали способы хранения и перечисления данных - структуры данных и итераторы.

Но в некоторых случаях данные должны быть **упорядочены** специфичным образом перед началом обработки.

Упорядочивание может производиться в двух режимах:

- данные остаются в том же самом хранилище (т.н. **_in-place_**)
- данные копируются в новое хранилище, которое и упорядочивается.

## Переворот

Наиболее простой способ упорядочивания - изменение порядка обработки на противоположный (`reverse`).

В большинстве случаев переворот может быть осуществлен в режиме in-place:

- Используются два итератора `left` и `right`, указывающие изначально на первый и последний элементы.
- На каждом шаге итерации значения в итераторах меняются, после чего `left` увеличивается, а `right` уменьшается.
- Итерация продолжается, пока `left` указывает на элемент "левее" итератора `right`.

### Реализация

Пример реализации переворота массива на C++:

```cpp
for (size_t left = 0, right = a.size() - 1; left < right; ++left, --right)
{
  std::swap(a[left], a[right]);
}
```

## Сортировка

В большинстве ситуаций данные необходимо переставить каким-то более сложным образом, чем простой переворот.

В таком случае логично говорить о **сортировке** данных относительного заданного **отношения строгого порядка**.

### Отношение порядка

#### Отношение строгого порядка

Зададим булеву функцию (предикат) $F(x, y)$, определенный для всех возможных значений массива $A$.

Функцию $F$ называют **отношением строго порядка** - аналогом операции " $x < y$ ", если:

- $\neg{F(x, x)}$ ($\neg$ - логическое отрицание) - _антирефлексивность_.
- из $F(x, y)$ следует, что $\neg{F(y, x)}$ - _антисимметричность_.
- из $F(x, y)$ и $F(y, z)$ следует, что $F(x, z)$ - _транзитивность_.

#### Равенство элементов относительно отношения порядка

Из отношения строгого порядка $F$ можно также определить отношение **эквивалентности** (равенства) $G(x, y)$. значений:

$G(x, y) = \neg{F(x, y)} \land \neg{F(y, x)}$ ($\land$ - логическое "И").

В таком случае на $G$ накладываются следующие условия:

- $G(x, x)$ - _рефлексивность_.
- из $G(x, y)$ следует $G(y, x)$ - _симметричность_.
- из $G(x, y)$ и $G(y, z)$ следует $G(x, z)$ - _транзитивность_.

По сути в случае эквивалентности значений $x$ и $y$ их порядок относительно друг от друга не определен.

#### Сортировка относительно отношения порядка

Массив $A$ считается **упорядоченным** относительного отношения порядка $F$, если для любого $i > 1$ верно, что

- ${F(A_{i - 1}, A_i)}$ - **строгое** упорядочивание.
- $\neg{F(A_i, A_{i - 1})}$ - **нестрогое** упорядочивание.

#### Ключ сравнения

В некоторых случаях встречается понятие "**ключа** сортировки" $K(x)$ - значения, по которому необходимо сравнивать элементы вместо оригинальных значений.

Например, при использовании баз данных / табличных менеджеров (Excel, Google Sheets) вы можете упорядочивать данные по определенной колонке / колонкам.

В этот момент вы по сути вводите компаратор, который сравнивает значения в данных колонках заместо целых строк таблицы.

### Отношение лексикографического порядка

В случае наличия нескольких ключей сортировки $K_1, K_2, \dots, K_m$ вводится понятие отношения **лексикографического** порядка.

Есть два основных случая использования лексикографического порядка:

- сложный объект, имеющий несколько атрибутов для сравнения.
- объект, являющийся последовательностью данных.

Вы наверняка уже встречались с таким порядком (причем чаще, чем можно подумать) - для строковых данных данный порядок часто называется "**алфавитным**".

#### Принцип работы для объектов с набором атрибутов

Допустим, у вас есть два объекта $a$ и $b$, каждый из которых задан набором ключей $K_1, K_2, \dots, K_m$.

В таком случае сравнение в лексикографическом порядке производится следующим образом:

- если $K_1(a) \ne K_1(b)$ - то результат сравнения определяется сравнением ключей $K_1$.
- (в ином случае) если $K_2(a) \ne K_2(b)$ - то результат сравнения определяется сравнением ключей $K_2$.
- (в ином случае) если $K_3(a) \ne K_3(b)$ - то результат сравнения определяется сравнением ключей $K_3$.
- $\dots$
- (в ином случае) если $K_m(a) \ne K_m(b)$ - то результат сравнения определяется сравнением ключей $K_m$.
- (в ином случае) если все $m$ ключей эквивалентны, то объекты $a$ и $b$ считаются эквивалентными.

Пример реализации на C++:

```cpp
auto cmp_1 = compare(a.key_1, b.key_1);
if (cmp_1 != equal) return cmp_1;

auto cmp_2 = compare(a.key_2, b.key_2);
if (cmp_2 != equal) return cmp_2;

// ...

return compare(a.key_m, b.key_m);
```

#### Принцип работы для последовательностей данных

Если объекты $a$ и $b$ представляют собой последовательности данных, то принцип остаётся таким же.

В таком случае ключом $K_i$ является $i$-е значение в соответствующей последовательности.

Дополнительно вводится правило "префикса":

- пусть длина $a$ равна $L_a$, длина $b$ равна $L_b$ и $L_a < L_b$ (случай $L_a > L_b$ аналогичен).
- пусть последовательности $a$ и $b$ эквивалентны по всем элементам от $1$-го до $L_a$-го включительно.
- в таком случае последовательность $a$ является **префиксом** последовательности $b$ и считается **лексикографически меньше** $b$.

Пример реализации на C++:

```cpp
size_t a_len = a.size(), b_len = b.size();
for (size_t i = 0; i < std::min(a_len, b_len); ++i)
{
  auto cmp = compare(a[i], b[i]);
  if (cmp != equal) return cmp;
}

return compare(a_len, b_len);
```

На самом деле можно заметить, что сравнение объектов с несколькими атрибутами фактически является разворачиванием данного цикла в набор последовательных инструкций (вследствие фиксированного количества атрибутов).

### Устойчивость сортировки

Сортировка называется **устойчивой (стабильной)**, если она сохраняет относительный порядок эквивалентных элементов.

Некоторые алгоритмы сортировки являются устойчивыми по своей сути.

В то же время любая нестабильная сортировка может быть превращена в стабильную преобразованием данных:

- пусть необходимо отсортировать массив $A$.
- построим новый массив $B$, где $B_i = (A_i, i)$ - пара значений.
- отсортируем массив $B$, используя лексикографическое сравнение:
  - если $A_i \ne A_j$ - соответствующие элементы $B_i$ и $B_j$ будут отсортированы в таком же порядке.
  - если $A_i = A_j$, то $B_i$ и $B_j$ будут упорядочены в порядке сравнения $i$ и $j$.