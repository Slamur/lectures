# Применения словаря на массиве

## Позиция каждого значения в последовательности

Дана последовательность $a_1, \dots, a_n$ из целых чисел в промежутке $[1; K]$.

Известно, что все элементы $a_i$ **различны**.

Для каждого присутствующего значения $v$ в последовательности выведите его позицию в последовательности.

### Решение

- Создадим целочисленный массив **позиций** $Pos$ размером $K + 1$, заполненный $-1$.
- Для каждого значения $a_i$ в массиве присвоим $Cnt_{a_i}$ значение $i$.
- Переберем все значения $v$ от $1$ до $K$ и выведем пару $(v, Pos_v)$, если $Pos_v \ne -1$.

Итоговая временная сложность $O(N + K)$, дополнительная память - $O(K)$.

**С++**:

```cpp
std::vector<int> pos(k + 1, -1);
for (size_t i = 0; i < n; ++i)
{
  pos[a[i]] = i;
}

for (int v = 1; v <= k; ++v)
{
  if (pos[v] == -1) continue;

  std::cout << v << " " << pos[v] << "\n";
}
```

## Количество каждого значения в последовательности

Дана последовательность $a_1, \dots, a_n$ из целых чисел в промежутке $[1; K]$.

Для каждого присутствующего значения $v$ в последовательности вычислите его количество (**частоту**).

- Формально для каждого значения $v$ необходимо вычислить количество позиций $i$ таких, что $a_i = v$.

### Решение

- Создадим целочисленный массив **счетчиков** $Cnt$ размером $K + 1$, заполненный $0$.
  - Массив $Cnt$ еще называют **частотным** массивом.
- Для каждого значения $v$ в массиве увеличим $Cnt_v$ на $1$.
- Переберем все значения $v$ от $1$ до $K$ и выведем пару $(v, Cnt_v)$, если $Cnt_v > 0$.

Итоговая временная сложность $O(N + K)$, дополнительная память - $O(K)$.

**С++**:

```cpp
std::vector<int> cnt(k + 1, 0);
for (auto& v : a) cnt[v]++;

for (int v = 1; v <= k; ++v)
{
  if (cnt[v] == 0) continue;

  std::cout << v << " " << cnt[v] << "\n";
}
```

## Сортировка подсчётом

Дана последовательность $a_1, \dots, a_n$ из целых чисел в промежутке $[1; K]$.

Построить отсортированную копию массива за $O(N + K)$.

### Решение

- Вычислим частотный массив $Cnt$.
- Создадим пустой динамический массив $S$ для хранения отсортированного результата.
- Переберём значения $v$ от $1$ до $K$ и $Cnt_v$ раз добавим значение $v$ в конец $S$.

**C++**:

```cpp
std::vector<int> sorted;
for (int v = 1; v <= k; ++v)
{
  for (int i = 0; i < cnt[v]; ++i) sorted.push_back(v);
}
```

Также вместо внутреннего цикла можно использовать операции с итераторами (ценой создания промежуточного `std::vector`):

```cpp
std::vector<int> sorted;
for (int v = 1; v <= k; ++v)
{
  std::vector<int> v_block(cnt[v], v);
  sorted.insert(sorted.end(), v_block.begin(), v_block.end());
}
```