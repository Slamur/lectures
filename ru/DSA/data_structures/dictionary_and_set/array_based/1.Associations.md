# Другой (?) взгляд на массив

## Последовательность

Вероятно, вы привыкли думать о массиве как о последовательности **значений**:

- найти максимальное **значение**;
- найти сумму **значений**;
- вывести **значения** в обратном порядке.

Да, значения хранятся в массиве в определенном порядке, задаваемом **индексами**, но обычно это больше формальность или неизбежность реализации.

Сами по себе индексы обычно не несут какой-то заметной смысловой нагрузки - это просто способ получить доступ к значению, не более.

Но всегда ли это так?

## Набор ассоциаций (словарь)

Давайте попробуем посмотреть на массив с точки зрения **индексов**.

В таком случае массив можно представить в виде набора **ассоциаций** $(i, a_i)$, где

- $i$ - индексы (назовём их **ключами**);
- $a_i$ - сопоставленные ключам **значения**.

### Операции с ассоциациями

Опишем операции, которые мы выполняем на массиве относительно индексов (ключей):

- `get(key)` - получить значение, сопоставленное ключу.
- `set(key, value)` - установить новую ассоциацию для заданного ключа.
- `size()` - получить общее количество хранимых ассоциаций.
- `iterator()` - получить итератор на все хранящиеся ассоциации в виде пар $(key, value)$.

В общем случае структура данных, выполняющая подобные операции, называется "**словарь**" (или "**ассоциативный массив**").

### Гарантии в рамках словаря

Абстракция словаря обычно удовлетворяет нескольким гарантиям:

- Ключи:
  - **уникальны** в рамках словаря;
  - память, занимаемая словарём, **линейно** зависит от количества ключей $N$.
  - временная сложность перебора элементов **линейно** зависит от количества ключей $N$.
- Значения:
  - нет ограничения на уникальность ($a_i$ может совпадать с $a_j$);
  - могут иметь любой тип данных;
  - память, занимаемая словарём, **линейно** зависит только от **типа данных** значений.
    - в случае значений, хранимых в динамической памяти, сам словарь хранит только указатели (которые как раз имеют фиксированный размер).

## Словарь на основе массива

Словарь может быть реализован по-разному, но в данный момент мы рассмотрим реализацию на **основе массива**.

Природа ключей как **индексов** приносит некоторые дополнительные гарантии (ограничения):

  - ключи обязаны быть **целыми неотрицательными** числами;
  - количество ключей становится равным **максимальному ключу** $N$.
    - если в таком словаре хранятся ключи $L$ и $R$, то и хранятся все ключи $L \le K \le R$.

В то же время на значения каких-то дополнительных гарантий не накладывается.

### Сложность операций

- `get(key)` и `set(key)` выполняются за $O(1)$;
- `size()` тоже за $O(1)$.
- перебор всех элементов за $O(N)$.

## Вопросы для самопроверки

Вопросы относятся к словарю **на основе массива**.

- Сколько памяти занимает массив из $10^6$ значений типа `int`? Округлите до мегабайт.
  - А если значений $10^9$? Округлите до мегабайт / гигабайт.
- Оцените сложность операций и занимаемую память, если ключи словаря:
  - целые числа в промежутке $[K_L; K_R]$;
    - что меняется, если $K_L < 0$?
  - квадраты натуральных чисел из промежутка $[0; N]$ (сами квадраты лежат, соответственно, в промежутке $[0; N^2]$);
  - любые ASCII-символы;
  - строчные (lower case) символы латинского алфавита;
    - строчные и заглавные символы;
    - строки из двух символов латинского алфавита.
  - клетки шахматной доски.