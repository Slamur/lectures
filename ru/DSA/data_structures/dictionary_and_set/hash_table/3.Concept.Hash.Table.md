# Хэш-таблица

До этого мы говорили о том, что в случае построения биекции между ключами и целыми **индексами** можно использовать "словарь на массиве".

Но в случае хеш-функций надо всегда учитывать возможные случаи коллизий и успешно их **разрешать**.

Структуры данных, которые используют хеш-функции и применяют какие-либо техники разрешения коллизий, называются **хеш-таблицами**.

## Общие принципы

Обычно хеш-таблицы строятся на основе массивов, где каждому ключу соответствует определенная ячейка:

- поступает запрос относительно ключа $K$;
- вычисляется хеш $H(K)$;
- вычисляется номер ячейки $P = H(K) \mod С$, где $С$ - количество ячеек в словаре.
- при необходимости производится разрешение возникающей коллизии, когда данная ячейка уже занята другим ключом.

## Разрешение коллизий

В данный момент существует два основных принципа разрешения коллизий: метод корзин и метод открытой адресации.

### Метод корзин

Вместо прямого хранения значения ячейка хеш-таблицы начинает хранить последовательность пар (ключ, значение).

В качестве последовательности чаще всего выступает связный список, но вообще это может быть любая структура данных, умеющая производить эффективно следующие операции:

- последовательный перебор элементов / поиск элемента;
- добавление элемента;
- удаление элемента по итератору.

Само разрешение коллизий выглядит достаточно просто:

- проверяем наличие искомого ключа с помощью функции сравнения **на равенство**.
  - сам поиск может быть линейным (в случае связного списка) или основываться на других параметрах ключа.
- если ключа в ячейке нет - добавляем ключ / ассоциацию как новый элемент ячейки.
- возвращаем соответствующий итератор.

### Открытая адресация

Открытая адресация, в отличие от метода корзин, продолжает работать с одномерным массивом значений.

В случае коллизии для ключа начинается поиск новой ячейки - зачастую правило выражено как специальная функция перехода.

Поиск продолжается итеративно, пока не будет найдена пустая ячейка или ячейка с искомым ключом.

Это верно как для добавления нового ключа, так и для поиска уже существующего.

#### Удаление ключей

Из-за особенности поиска ячеек при открытой адресации удаление ключей требуется производить особенно аккуратно:

- либо ячейка просто помечается "удаленной" и не используется в дальнейшем;
- либо производятся дополнительные действия для "переноса" ключей для сохранения консистентности поиска.

## Сложность операций

Допустим, размер массива хеш-таблицы равен $C$, а количество ключей в ней равно $N$.

### Амортизированная оценка

При выборе "хорошей" хеш-функции **среднее** количество операций для разрешения коллизий будет равно $O(\frac{N}{C})$.

Величину $\frac{N}{C}$ называют **load factor** - она является одним из важных критериев при работе с хеш-таблицей.

При возрастании load factor происходит естественное падение эффективности разрешения коллизий, поэтому хеш-таблица **перестраивается**:

- для метода корзин нет четкой границы, когда перестройка необходима. Обычно считается, что load factor от 1 до 3 вполне приемлем.
- для метода открытой адресации load factor не может подниматься выше 1 по определению. Поэтому чаще всего его стараются поддерживать на уровне не выше 0.6 - 0.75.

Суммарная амортизированная оценка получается равной $O(1)$:

- $O(\frac{N}{C})$ **в среднем** на каждый запрос к ключам;
- перестройка таблицы за $O(C)$, но производимая редко (доказательство аналогично ситуации с динамическим массивом).

### Худший случай

Довольно очевидно, что в худшем случае операции с ключами могут выполняться за $O(N)$ вместо ожидаемого $O(1)$:

- все ключи попадают в одну и ту же корзину;
- поиск пустой ячейки при открытой адресации вырождается в перебор практически всех ячеек таблицы.

В реальной жизни такое случается нечасто, но всегда стоит помнить об этом. Обычно к этому приводит один из двух факторов:

- выбор неподходящей хеш-функции.
- целенаправленная атака на искомый алгоритм.

### Итерация по ключам

В простом случае итерация производится за $O(C + N)$:

- перебираем все ячейки хеш-таблицы, даже пустые.
- для всех ячеек с ключами производим соответствующее действие в рамках итерации.

Также очень важно понимать, что в таком случае итерация производится в порядке, связанном с хеш-функциями ключей и параметром $C$.

В большинстве ситуаций этот порядок сложно предсказуем, поэтому обычно считается, что порядок итерации по хеш-таблице **не является упорядоченным** по какому-то критерию.

#### Связная хеш-таблица

Для более эффективной обработки используют принцип "связной хеш-таблицы":

- каждая запись с ключом теперь является ячейкой специального связного списка;
- при добавлении нового ключа он добавляется в конец соответствующего списка.
- такой подход позволяет игнорировать пустые ячейки и производить итерацию за $O(N)$.

Еще одним плюсом такого подхода зачастую является упорядоченность итерации **по времени последнего обращения к ключу** (least recently used).

Обратите внимание - это не итерация в порядке возрастания или убывания самих ключей, это именно порядок вставки/обновления ключей в рамках хеш-таблицы.