# Аргумент обмена

"Аргумент обмена" - это обобщение подхода, описанного в предыдущем разделе.

Он позволяет построить (и доказать) компаратор для жадного подхода в более сложных случаях.

## Общая информация

### Задача

У вас есть массив $a$ из $n$ элементов и функция $F(a)$.

Значение $F$ зависит **только** от двух вещей:

- **значений** $a$,
- **порядка** значений.
  - **важно**: любая перестановка $a$ должна быть допустимым входом для $F$.

Найдите такой порядок $a$, который максимизирует $F(a)$.

- Часто вы можете встретить утверждения, которые просят вас найти "наиболее оптимальное значение $F$".
  - Вы можете задать вопрос: оптимальное по сравнению с чем?
  - Ответ - по сравнению с **всеми другими возможными** порядками $a$.

### Решение

- Представьте, что вы каким-то образом нашли оптимальный порядок $a$.

- Пусть элемент $a_j$ - следующий за $a_i$ в оптимальном порядке.
  - Почему лучше иметь $a_i$ перед $a_j$, чем $a_j$ перед $a_i$?

- Рассчитайте $\Delta{F}(i, j)$ в случае, если вы обменяете **только** $a_i$ и $a_j$ в найденном порядке.
  - $\Delta{F}(i, j)$ должно быть $\le 0$ для любой пары $(i, j)$ - в противном случае исходный порядок не был оптимальным.
    - Вы можете рассматривать это как условие "локальной оптимальности" - любое небольшое изменение порядка не должно улучшать $F$.
  - Эти обмены могут быть выполнены **только благодаря** тому, что любая перестановка $a$ является допустимым входом для $F$.

- Обычно вы можете рассмотреть 4 части порядка при расчете $\Delta{F}(i, j)$:
  - часть перед $a_i$ - не меняется,
  - $a_i$,
  - $a_j$,
  - часть после $a_j$ - не меняется.

- Отсортируйте массив $a$, используя $\Delta{F}(i, j)$ в качестве **компаратора**.

## Наименьшая лексикографическая конкатенация

### Задача

У вас есть $n$ строк $s_i$.

Вы хотите объединить их в таком порядке, чтобы получившаяся строка была лексикографически наименьшей.

### Решение

- Функция $F(s)$ - это конкатенация строк в порядке $s$.
- Пусть $s_j$ - следующая строка для $s_i$ в оптимальном порядке.
  - Почему лучше иметь $s_i$ перед $s_j$, чем $s_j$ перед $s_i$?
    - Пусть у нас уже есть префикс конкатенированной строки $P$ перед $s_i$ и конкатенированный суффикс $S$ после $s_j$.
    - В первом случае у нас есть $P + s_i + s_j + S$.
    - Во втором случае у нас есть $P + s_j + s_i + S$.
    - Сравните две конкатенации: 
      - $P + s_i + s_j + S < P + s_j + s_i + S$.
      - $P$ - это общий префикс, $S$ - общий суффикс, поэтому мы можем удалить их из обеих сторон.
      - Таким образом, у нас есть $s_i + s_j < s_j + s_i$.
- Таким образом, **компаратор**, который вам нужен, - это $s_i + s_j < s_j + s_i$.
- Общая сложность составляет $O(n \log n \cdot k)$, где $k$ - максимальная длина строк.

### Пример на C++

```cpp
auto get_ans = [&]() {
    auto order = s;
    std::sort(order.begin(), order.end(),
        // < 
        [](const auto& first, const auto& second) {
            return first + second < second + first;
        }
    };
    
    std::string ans = "";
    for (auto& word : order) ans += word;
    
    return ans;
}
```

## Дробный рюкзак

### Задача

У вас есть $n$ предметов, каждый с весом $w_i$ и стоимостью $c_i$.

У вас есть рюкзак с емкостью $W$.

Вы можете взять любую долю каждого предмета (представьте, что предметы - это мешки с песком).

Вы хотите максимизировать общую стоимость предметов в рюкзаке, но общий вес не должен превышать $W$.

### Решение

- Пусть $a_i$ - это предмет с весом $w_i$ и стоимостью $c_i$.
- Функция $F(a)$ - это максимальная стоимость предметов в рюкзаке, если вы начинаете брать предметы в порядке $a$.
- Пусть $a_j$ - следующий предмет для $a_i$ в оптимальном порядке.
  - Почему лучше иметь $a_i$ перед $a_j, чем $a_j$ перед $a_i$?
    - Пусть мы уже взяли $P$ веса предметов перед $a_i$
      - Пусть $D = W - P$ - оставшаяся емкость рюкзака.
    - Если $D \ge w_i + w_j$, то не имеет значения, в каком порядке вы берете $a_i$ и $a_j$ - вы можете взять оба полностью.
    - В противном случае, пусть $D \ge \max(w_i, w_j)$:
      - В первом случае вы берете $w_i$ веса $a_i$ и $(D - w_i)$ веса $a_j$ - общая стоимость будет $c_i + c_j \cdot \frac{D - w_i}{w_j}$.
      - Во втором случае вы берете $w_j$ веса $a_j$ и $(D - w_j)$ веса $a_i$ - общая стоимость будет $c_j + c_i \cdot \frac{D - w_j}{w_i}$.
      - Сравнивая эти два случая:
        - $c_i + c_j \cdot \frac{D - w_i}{w_j} < c_j + c_i \cdot \frac{D - w_j}{w_i}$.
        - $c_i \cdot \frac{w_i + w_j - D}{w_i} < c_j \cdot \frac{w_j + w_i - D}{w_j}$.
        - $\frac{c_i}{w_i} \cdot (w_i + w_j - D) < \frac{c_j}{w_j} \cdot (w_i + w_j - D)$.
        - $\frac{c_i}{w_i} < \frac{c_j}{w_j}$.
    - Другие случаи можно проанализировать аналогично с тем же результатом.
  - Таким образом, лучше иметь предмет с большим $\frac{c_i}{w_i}$ перед предметом с меньшим $\frac{c_j}{w_j}$.
    - На самом деле это имеет смысл с практической точки зрения:
      - вы хотите сначала брать предметы с большей стоимостью за единицу веса, потому что вы всегда **можете заполнить пустоты** более дешевыми.
    - Сравните это с задачей о 0/1 рюкзаке, где вы не можете брать дробные части предметов - там жадный подход не работает.
- Таким образом, **компаратор**, который вам нужен, - это $\frac{c_i}{w_i} < \frac{c_j}{w_j}$.
  - Чтобы избежать операций с плавающей запятой, вы можете использовать $c_i \cdot w_j < c_j \cdot w_i$.
- Общая сложность составляет $O(n \log n)$.

### Пример на C++

```cpp
auto get_ans = [&]() {
    auto order = items; // items - это вектор структур (стоимость, вес)
    std::sort(order.begin(), order.end(),
        // < 
        [](const auto& first, const auto& second) {
            return first.cost * second.weight > second.cost * first.weight;
        }
    };
	
    double ans = 0;
    
    size_t remaining_capacity = knapsack_capacity;
    for (auto& item : order) {
        size_t taken_weight = std::min(remaining_capacity, item.weight);
        ans += item.cost * ((double)taken_weight / item.weight);
        remaining_capacity -= take_weight;
    }
	
    return ans;
}
```

## Нет времени для драконов

### Задача

Вам нужно победить всех $n$ драконов.

Чтобы победить $i$-го дракона, вам нужно иметь армию с **как минимум** $a_i$ солдатами.

После того как вы победите $i$-го дракона, размер вашей армии **уменьшается** на $b_i$ солдат ($b_i \le a_i)$.

Вы можете сражаться с драконами в любом порядке.

Найдите минимальный начальный размер армии $S$, чтобы победить всех драконов.

### Решение

- Пусть $a_i$ - это $i$-й дракон.
- Функция $F(a)$ - это минимальный начальный размер армии, чтобы победить всех драконов, если вы побеждаете их в порядке $a$.
- Пусть $a_j$ - следующий дракон для $a_i$ в оптимальном порядке.
  - Почему лучше иметь $a_i$ перед $a_j, чем $a_j$ перед $a_i$?
    - Пусть мы уже победили некоторых драконов перед $a_i$ и $a_j$ и потеряли $P$ солдат.
    - Сколько солдат нам нужно иметь перед тем, как сразиться с $a_i$ и $a_j$?
      - В первом случае нам нужно иметь как минимум $\max(a_i, a_j + b_i)$ солдат.
      - Во втором случае нам нужно иметь как минимум $\max(a_j, a_i + b_j)$ солдат.
    - Мы хотим минимизировать $S$, поэтому мы также хотим минимизировать $S - P$.
      - Но $S - P$ должно быть не меньше, чем нужно для сражения с обоими $a_i$ и $a_j$.
      - Поэтому лучше выбрать порядок, в котором требуется меньшее количество солдат.
- Таким образом, **компаратор**, который вам нужен, - это $\max(a_i, a_j + b_i) < \max(a_j, a_i + b_j)$.
- Функцию $F$ можно реализовать со сложностью $O(n)$:
  - Начните с $S = 0$ и текущего размера армии $C = 0$.
  - Если $C$ меньше $a_i$, увеличьте $S$ и $C$ на $(a_i - C)$.
  - После победы над драконом уменьшите $C$ на $b_i$.
- Общая сложность составляет $O(n \log n)$.

### Пример на C++

```cpp
auto get_ans = [&]() {
    auto order = dragons; // dragons - это вектор структур (нужно, убито)
    std::sort(order.begin(), order.end(),
        // < 
        [](const auto& first, const auto& second) {
            return std::max(first.need, second.need + first.killed) <
                   std::max(second.need, first.need + second.killed);
        }
    };
    
    size_t ans = 0;
    size_t current_army = 0;
    for (auto& dragon : order) {
        if (current_army < dragon.need) {
            ans += (dragon.need - current_army);
            current_army = dragon.need;
        }
        current_army -= dragon.killed;
    }
    
    return ans;
}
```

# Вопросы

- Можете ли вы использовать аргумент обмена в задачах, где не любая перестановка входных данных является допустимой для $F$?

- В классической задаче "рюкзак" вы не можете брать дробные части предметов.
  - Известно, что эту задачу можно решить только с помощью динамического программирования.
  - Найдите контрпример, который показывает, что жадный подход с компаратором $\frac{c_i}{w_i} > \frac{c_j}{w_j}$ не работает в этом случае.

- Классическая задача "о коммивояжере":
  - **Утверждение**:
    - У вас есть $n$ городов и дороги между некоторыми из них.
    - Вы хотите найти кратчайший путь, который посещает каждый город **ровно один раз**.
    - Вы можете начать и закончить в любом городе.
  - Докажите, что подход "аргумента обмена" не применим в этом случае.
    - Почему не любая перестановка городов является допустимой для $F$?
  - Предположим, у нас есть полный граф (дороги между любыми двумя городами). 
    - Докажите, что подход "аргумента обмена" все равно не применим в этом случае.
      - Какой информации не хватает для подхода "аргумента обмена"?
    - Докажите, что жадный подход с компаратором "выберите ближайший ещё не посещенный город" не работает в этом случае.
      - Найдите контрпример.
