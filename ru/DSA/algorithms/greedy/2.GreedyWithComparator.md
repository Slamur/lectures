# Жадный подход с компаратором

## Общая информация

Как вы помните, жадный подход заключается в выборе локально оптимального ("лучшего") выбора для достижения глобально оптимального решения.

В большинстве случаев лучший выбор можно рассматривать как "наименьший" или "наибольший" элемент в соответствии с некоторыми критериями.

Обычно самая сложная часть - это найти правильные критерии и доказать, что такой жадный подход работает.

Давайте рассмотрим несколько примеров такого жадного подхода.

## Рюкзак с единичными весами

### Задача

У вас есть $n$ предметов, каждый с ценой $c_i$ и весом $1$.

У вас есть рюкзак с емкостью $W$.

Вы можете взять любые предметы в рюкзак, но общий вес не должен превышать $W$.

Вы хотите максимизировать общую стоимость предметов в рюкзаке.

### Решение

- Обратите внимание, что вы можете взять любые $W$ предметов.

- На первом шаге вы хотите взять предмет с наибольшей ценой $c_i$.
  - Допустим, это неправильно, и вы взяли предмет с ценой $c_j < c_i$.
  - Существуют два варианта:
    - Вы взяли предмет $c_j$ и не взяли предмет $c_i$.
      - Вы можете обменять $c_j$ на $c_i$ и получить лучшее решение.
    - Вы взяли оба предмета $c_i$ и $c_j$.
      - Не имеет значения, в каком порядке вы их взяли - вы можете обменять их и получить то же самое решение.

- Та же логика работает и на следующих шагах - вы всегда хотите взять предмет с наибольшей ценой $c_i$ среди оставшихся предметов.

- Таким образом, **компаратор**, который вам нужен, - это $c_i > c_j$.
  - Отсортируйте предметы по цене в порядке убывания и возьмите первые $W$ предметов.

- Общая сложность составляет $O(n \log n)$.

### Пример на C++

```cpp
auto get_ans = [&]() {
    std::sort(costs.begin(), costs.end(), std::greater<int>());
    
    int ans = 0;
    for (size_t i = 0; i < std::min(costs.size(), knapsack_capacity); i++)
        ans += costs[i];
    }
    
    return ans;
}
```

## Земля драконов

### Задача

У вас есть $n$ драконов на прямой.

Вы идете от дракона $1$ к дракону $n$ и не можете вернуться назад.

Вы можете победить любого дракона, которого захотите.

Если вы победили дракона $i$, и это был ваш $j$-й побежденный дракон, вы получаете $a_i$ монет, но должны заплатить $j$ монет за ремонт вашего меча.

**Важно**: ваше количество монет **не может быть отрицательным** в любой момент.

Вы начинаете с $0$ монет, и ваш меч не сломан.

Вы хотите максимизировать общее количество монет, которое у вас есть после победы над некоторыми драконами.

### Решение

- Обратите внимание, что вы можете победить любой подмножество драконов.
- Допустим, вы победили драконов $i_1, i_2, \ldots, i_k$ в этом порядке.
  - Общее количество монет, которое вы получите, составляет $(a_{i_1} - 1) + (a_{i_2} - 2) + \ldots + (a_{i_k} - k) = (a_{i_1} + a_{i_2} + \ldots + a_{i_k}) - (1 + 2 + \ldots + k)$.
  - Для фиксированного $k$ вы хотите максимизировать $(a_{i_1} + a_{i_2} + \ldots + a_{i_k})$.
    - Не имеет значения, в каком порядке вы берете этих драконов - вы можете обменять их и получить тот же результат.
- Давайте выберем подмножество драконов для победы.
  - Сначала вы хотите взять дракона с наибольшим $a_i$.
    - Доказательство такое же, как в предыдущей задаче.
  - По той же логике вы хотите брать драконов в порядке убывания $a_i$.
- Таким образом, **компаратор**, который вам нужен, - это $a_i > a_j$.
- Но какое $k$ является наилучшим?
  - Вернемся к исходной форме ответа: $(a_{i_1} - 1) + (a_{i_2} - 2) + \ldots + (a_{i_k} - k)$.
  - Берите драконов, пока $(a_{i_j} - j) \ge 0$.
    - Если $(a_{i_j} - j) < 0$, то вы можете пропустить победу над этим драконом и получить лучший результат.
- Общая сложность составляет $O(n \log n)$.

### Пример на C++

```cpp
auto get_ans = [&]() {
    std::sort(dragons.begin(), dragons.end(), std::greater<int>());
    
    int ans = 0;
    for (size_t i = 0; i < dragons.size(); i++) {
        int profit = dragons[i] - (i + 1);
        if (profit < 0) break;
        ans += profit;
    }
    
    return ans;
}
```

## Драконы и принцессы

### Задача

У вас есть $n$ башен на прямой, в каждой башне живет либо дракон, либо принцесса.

Вам нужно пройти от башни $1$ к башне $n$ и не можете вернуться назад.

Вы можете победить любого дракона, которого захотите.

Если вы победите дракона $i$, вы получите $a_i$ монет.

Но каждый раз, когда вы проходите башню $j$ с принцессой, она принудительно выйдет за вас замуж, если вы победили как минимум $a_j$ драконов до этого момента.

В последней $n$-й башне живет принцесса, которую вы любите, поэтому:

- вы должны избегать женитьбы на других принцессах,
- но вам также нужно победить как минимум $a_n$ драконов, прежде чем доберетесь до последней башни, чтобы произвести впечатление на вашу принцессу.

Если есть несколько способов жениться на **вашей** принцессе, вы хотите **максимизировать общее количество монет**, которое у вас есть после победы над драконами.

### Решение

- Вместо того чтобы пытаться победить драконов, давайте подумаем о том, как избежать женитьбы на принцессах.
  - Побеждайте всех драконов, которых встречаете.
  - Когда принцесса $j$ заставляет вас жениться на ней, вы хотите "отменить" победу над некоторыми ранее побежденными драконами.
    - Думайте об этом так, как будто вы никогда не побеждали этих драконов.
  - Но для каких драконов вы хотите "отменить" победу?
    - Принцесса смотрит только на количество побежденных драконов, а не на общее количество монет, которое у вас есть.
    - Поэтому вы всегда хотите "отменить" дракона с наименьшим $a_i$ среди ранее побежденных.
      - Доказательство такое же, как в предыдущих задачах.
- Таким образом, **компаратор**, который вам нужен, - это $a_i < a_j$.
  - Основное отличие от предыдущих задач заключается в том, что вы не можете просто отсортировать драконов по $a_i$ и взять максимальное $b_n$ из них.
  - Вместо этого вам нужно хранить побежденных драконов в структуре данных, которая поддерживает следующие операции:
    - добавить золото $a_i$ побежденного дракона;
      - могут быть **дубликаты** $a_i$.
    - получить и удалить побежденного дракона с наименьшим $a_i$.
  - Легко увидеть, что все эти операции поддерживаются **очередью с приоритетом**.
    - Используйте реализацию очереди с приоритетом на основе **двоичной кучи**, чтобы получить сложность $O(\log n)$ для каждой операции.
- Общая сложность составляет $O(n \log n)$.

### Пример на C++

```cpp
auto get_ans = [&]() {
    std::priority_queue<int, std::vector<int>, std::greater<int>> defeated_dragons;
    
    // обрабатываем все, кроме последней башни
    for (size_t i = 0; i + 1 < n; ++i) { 
        if (is_dragon[i]) {
            int gold = a[i];
            defeated_dragons.push(gold);
        } else { // это принцесса
            int min_defeated_dragons_to_marry = a[i];
            while (defeated_dragons.size() >= min_defeated_dragons_to_marry) {
                defeated_dragons.pop();
            }
        }
    }
    
    if (defeated_dragons.size() < a[n - 1]) {
        return -1; // невозможно произвести впечатление на вашу принцессу
    }
    
    int ans = 0;
    while (!defeated_dragons.empty()) {
        ans += defeated_dragons.top();
        defeated_dragons.pop();
    }
    
    return ans;
}
```

# Вопросы

- В классической задаче "о рюкзаке" предметы также имеют веса $w_i$.
  - Известно, что эту задачу можно решить только с помощью динамического программирования.
  - Найдите контрпример, который показывает, что жадный подход с компаратором $c_i > c_j$ не работает в этом случае.
- В задаче "Земля драконов" мы на самом деле пропустили одну деталь:
  - мы нашли подмножество драконов для победы, но в порядке, который был "удобен" для нас;
  - но согласно условию задачи нам нужно побеждать драконов в порядке, в котором они расположены на линии.
  - **докажите**, что всегда возможно победить выбранных драконов в исходном порядке, не переходя в отрицательное количество монет в процессе.
    - Используйте неравенство $k \le a_{i_k} \le a_{i_{k - 1}} \le \ldots$.
- Давайте изменим задачу "Драконы и принцессы":
  - теперь принцесса $j$ принудительно выйдет за вас замуж, если ваше общее количество монет будет не менее $a_j$.
  - **найдите** контрпример, который показывает, что жадный подход с "отменой" победы над драконами с наименьшим $a_i$ не работает в этом случае.
  - **докажите**, что этот вариант задачи нельзя решить с помощью жадного подхода вообще.
    - сведите задачу к той, про которую вы знаете, что её нельзя решить жадным подходом.