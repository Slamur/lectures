# Greedy approach with comparator

## General

As you remember, greedy approach is about choosing the local optimal ("best") choice to reach the global optimal solution.

In most cases best choice can be thought as "the smallest" or "the largest" element according to some criteria.

Usually the hardest part is to find the right criteria and to prove that such greedy approach works.

Let's look at some examples of such greedy approach.

## Knapsack with unit weights

### Problem

You have $n$ items, each with cost $c_i$ and weight $1$.

You have knapsack with capacity $W$.

You can take any items in the knapsack, but total weight should not exceed $W$.

You want to maximize total cost of the items in the knapsack.

### Solution

- Notice that you can take any $W$ items.

- On the first step you want to take the item with the largest cost $c_i$.
  - Lets it's wrong, and you took item with cost $c_j < c_i$.
  - There are two possibilities:
    - You took item $c_j$ and did not take item $c_i$.
      - You can exchange $c_j$ with $c_i$ and get better solution.
    - You took both items $c_i$ and $c_j$.
      - It doesn't matter what order you took them - you can exchange them and get the same solution.
      
- Same logic works for the next steps - you always want to take the item with the largest cost $c_i$ among the remaining items.

- So the **comparator** you need is $c_i > c_j$.
  - Sort items by cost in descending order and take first $W$ items.
  
- Total complexity is $O(n \log n)$.

### C++ example

```cpp
auto get_ans = [&]()
    std::sort(costs.begin(), costs.end(), std::greater<int>());
    
    int ans = 0;
    for (size_t i = 0; i < std::min(costs.size(), knapsack_capacity); i++)
        ans += costs[i];
    }
    
    return ans;
}
```    

## The Dragon Land

### Problem

You have $n$ dragons on the line.

You are going from dragon $1$ to dragon $n$ and can't return back.

You can defeat any dragons you want.

If you defeated dragon $i$, and it was your $j$-th defeated dragon, you get $a_i$ coins, but should pay $j$ coins back to repair your sword.

You start with $0$ coins and your sword is not broken.

You want to maximize total number of coins you have after defeating some dragons.

### Solution

- Notice that you can defeat any subset of dragons.
- Lets you defeated dragons $i_1, i_2, \ldots, i_k$ in this order.
  - Total number of coins you get is $(a_{i_1} - 1) + (a_{i_2} - 2) + \ldots + (a_{i_k} - k) = (a_{i_1} + a_{i_2} + \ldots + a_{i_k}) - (1 + 2 + \ldots + k)$.
  - For the fixed $k$ you want to maximize $(a_{i_1} + a_{i_2} + \ldots + a_{i_k})$.
    - It does not matter what order you take those dragons - you can exchange them and get the same result.
- Let's choose the subset of dragons to defeat.
  - First you want to take the dragon with the largest $a_i$.
    - Proof is the same as in the previous problem.
  - By the same logic you want to take dragons in the order of decreasing $a_i$.
- So the **comparator** you need is $a_i > a_j$.
- But what $k$ is the best?
  - Return to the original form of the answer: $(a_{i_1} - 1) + (a_{i_2} - 2) + \ldots + (a_{i_k} - k)$.
  - Take dragons while $(a_{i_j} - j) \ge 0$.
    - If $(a_{i_j} - j) < 0$, then you can skip defeating this dragon and get better result.
- Total complexity is $O(n \log n)$.

### C++ example

```cpp
auto get_ans = [&]() {
    std::sort(dragons.begin(), dragons.end(), std::greater<int>());
    
    int ans = 0;
    for (size_t i = 0; i < dragons.size(); i++) {
        int profit = dragons[i] - (i + 1);
        if (profit < 0) break;
        ans += profit;
    }
    
    return ans;
}
```

## Dragons and Princesses

### Problem

You have $n$ towers on the line, in each tower lives either a dragon or a princess.

You need to go from tower $1$ to tower $n$ and can't return back.

You can defeat any dragons you want.

If you defeat dragon $i$, you get $a_i$ coins.

But each time you are passing tower $j$ with a princess, she will forcefully marry you if you defeated at least $a_j$ dragons so far.

In the last $n$-th tower lives a princess you love, so:

- you must avoid marrying other princesses,
- but you also need to defeat at least $a_n$ dragons before reaching the last tower to impress your princess.

If there are several ways to marry **your** princess, you want to **maximize total number of coins** you have after defeating dragons.

### Solution

- Instead of trying to defeat dragons, let's think about avoiding marrying princesses.
  - Defeat all dragons you meet.
  - When princess $j$ forces you to marry her, you want to "undo" defeating some previously defeated dragons.
    - Think about this as if you never defeated those dragons.
  - But what dragons you want to "undo" defeating?
    - Princess is looking only at the number of defeated dragons, not at the total number of coins you have.
    - So you always want to revive the dragon with the smallest $a_i$ among the previously defeated dragons.
      - Proof is the same as in the previous problems.
- So the **comparator** you need is $a_i < a_j$.
  - Main difference from the previous problems is that you can't simply sort dragons by $a_i$ and take maximal $b_n$ of them.
  - Instead, you need to store defeated dragons in the data structure that supports next operations:
    - add gold $a_i$ of the defeated dragon;
      - there can be **duplicates** of the $a_i$.
    - get and remove the defeated dragon with the smallest $a_i$.
  - Easy to see that all those operations are support by the **priority queue**.
    - Use binary heap implementation of the priority queue to get $O(\log n)$ complexity of each operation.
- Total complexity is $O(n \log n)$.

### C++ example

```cpp
auto get_ans = [&]() {
    std::priority_queue<int, std::vector<int>, std::greater<int>> defeated_dragons;
    
    // process all but the last tower
    for (size_t i = 0; i + 1 < n; ++i) { 
        if (is_dragon[i]) {
            int gold = a[i];
            defeated_dragons.push(gold);
        } else { // is princess
            int min_defeated_dragons_to_marry = a[i];
            while (defeated_dragons.size() >= min_defeated_dragons_to_marry) {
                defeated_dragons.pop();
            }
        }
    }
    
    if (defeated_dragons.size() < a[n - 1]) {
        return -1; // impossible to impress your princess
    }
    
    int ans = 0;
    while (!defeated_dragons.empty()) {
        ans += defeated_dragons.top();
        defeated_dragons.pop();
    }
    
    return ans;
}
```