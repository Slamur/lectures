# Exchange argument

## General

### Problem

You have array $a$ of $n$ elements and function $F(a)$. 

Value of the $F$ depends **only** on the two things:

- **values** of $a$, 
- **order** of the values.
  - **important**: any permutation of $a$ is valid input for $F$.

Find such order of $a$ that maximizes $F(a)$.

- Often you can have the statements that asks you to find "the most optimal value of $F$"
  - You can have the question: optimal compared to what?
  - Answer is - compared to **all other possible** orders of $a$.

### Solution

- Imagine that you somehow found the optimal order of $a$.

- Lets element $a_j$ is the next one for the $a_i$ in the optimal order.
  - Why is it better to have $a_i$ before $a_j$ than $a_j$ before $a_i$?
  
- Calculate $\Delta{F}(i, j)$ in the case you exchange **only** $a_i$ and $a_j$ in the found order.
  - $\Delta{F}(i, j)$ should be $\le 0$ for any pair $(i, j)$ - otherwise found order was not optimal.
    - You can think about this as a "local optimality" condition - any small change to the order should not improve $F$.
  - Those swaps can be done **only because** the fact that any order of $a$ is valid input for $F$.

- Usually you can think about 4 parts of the order during $\Delta{F}(i, j)$ calculation:
  - part before $a_i$ - does not change,
  - $a_i$,
  - $a_j$,
  - part after $a_j$ - does not change.

- Sort array $a$, using $\Delta{F}(i, j)$ as **comparator**.

## Smallest lexicographical concatenation

### Problem

You have $n$ strings $s_i$.

You want to concatenate them in such order that the resulting string is lexicographically smallest.

### Solution

- Function $F(s)$ is the concatenation of strings in the order of $s$.
- Lets $s_j$ is the next string for the $s_i$ in the optimal order.
  - Why is it better to have $s_i$ before $s_j$ than $s_j$ before $s_i$?
    - Lets we already have prefix concatenated prefix $P$ before $s_i$ and concatenated suffix $S$ after $s_j$.
    - In the first case we have $P + s_i + s_j + S$.
    - In the second case we have $P + s_j + s_i + S$.
    - Compare two concatenations: 
      - $P + s_i + s_j + S < P + s_j + s_i + S$.
      - $P$ is common prefix, $S$ is common suffix, so we can remove them from both sides.
      - So we have $s_i + s_j < s_j + s_i$.
- So the **comparator** you need is $s_i + s_j < s_j + s_i$.
- Total complexity is $O(n \log n \cdot k)$, where $k$ is the maximum length of strings.

### C++ example

```cpp
auto get_ans = [&]()
{
    auto order = s;
    std::sort(order.begin(), order.end(),
        // < 
        [](const auto& first, const auto& second)
        {
            return first + second < second + first;
        }
    };
    
    std::string ans = "";
    for (auto& word : order) ans += word;
    
    return ans;
}
```

## Fractional knapsack

### Problem

You have $n$ items, each with weight $w_i$ and cost $c_i$.

You have knapsack with capacity $W$.

You can take any fraction of each item (think about items as bags with sand).

You want to maximize total cost of items in the knapsack, but total weight should not exceed $W$.

### Solution

- Lets $a_i$ be the item with weight $w_i$ and cost $c_i$.
- Function $F(a)$ is the maximum cost of items in the knapsack, if you start taking items in order of $a$.
- Lets $a_j$ is the next item for the $a_i$ in the optimal order.
  - Why is it better to have $a_i$ before $a_j$ than $a_j$ before $a_i$?
    - Lets we already took $P$ weight of items before $a_i$
      - Lets $D = W - P$ be the remaining capacity of the knapsack.
    - If $D \ge w_i + w_j$, then it does not matter what order you take $a_i$ and $a_j$ - you can take both of them fully.
    - Otherwise, lets $D \ge \max(w_i, w_j)$:
      - In the first case you take $w_i$ weight of $a_i$ and $(D - w_i)$ weight of $a_j$ - total cost will be $c_i + c_j \cdot \frac{D - w_i}{w_j}$.
      - In the second case you take $w_j$ weight of $a_j$ and $(D - w_j)$ weight of $a_i$ - total cost will be $c_j + c_i \cdot \frac{D - w_j}{w_i}$.
      - Comparing those two cases:
        - $c_i + c_j \cdot \frac{D - w_i}{w_j} < c_j + c_i \cdot \frac{D - w_j}{w_i}$
        - $c_i \cdot \frac{w_i + w_j - D}{w_i} < c_j \cdot \frac{w_j + + w_i - D}{w_j}$
        - $\frac{c_i}{w_i} \cdot (w_i + w_j - D) < \frac{c_j}{w_j} \cdot (w_i + w_j - D)$
        - $\frac{c_i}{w_i} < \frac{c_j}{w_j}$
    - Other cases could be analyzed similarly with the same result.
  - So it's better to have item with larger $\frac{c_i}{w_i}$ before item with smaller $\frac{c_j}{w_j}$.
    - Actually it makes sense from the practical point of view:
      - you want to take items with larger cost per weight unit first because you always **can fill the gaps** with the cheaper ones.
    - Compare this with the 0/1 knapsack problem, where you cannot take fractions of items - there greedy approach does not work.
- So the **comparator** you need is $\frac{c_i}{w_i} < \frac{c_j}{w_j}$.
  - To avoid floating point operations you can use $c_i \cdot w_j < c_j \cdot w_i$.
- Total complexity is $O(n \log n)$.

### C++ example

```cpp
auto get_ans = [&]()
{
    auto order = items; // items is vector of structs (cost, weight)
    std::sort(order.begin(), order.end(),
        // < 
        [](const auto& first, const auto& second)
        {
            return first.cost * second.weight > second.cost * first.weight;
        }
    };
	
    double ans = 0;
    
    int remaining_capacity = knapsack_capacity;
    for (auto& item : order)
    {
        int taken_weight = std::min(remaining_capacity, item.weight);
        ans += item.cost * ((double)taken_weight / item.weight);
        remaining_capacity -= take_weight;
    }
	
    return ans;
}
```