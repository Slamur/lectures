# Пререквизиты

## Инцидентность

Ребро $(a, b)$ **инцидентно** вершине $v$, если $v = a$ или $v = b$.

## Степень вершины

Количество инцидентных вершине рёбер.

Обозначается через $d_v$ или $deg_v$ (от англ. слова *degree* - "степень").

В случае ориентированного графа различают **исходящую** и **входящую** степени $d^{in}_v$ и $d^{out}_v$.

### Сумма степеней вершин

Если в неориетированном графе суммарно $E$ рёбер, то верно соотношение $\sum{d_v} = 2 \cdot E$.

Для ориентированного графа соотношение принимает вид $\sum{d^{in}_v} = \sum{d^{out}_v} = E$.

## Списки смежности

Способ хранения графа, представляемый массивом списков.

Список под индексом $v$ хранит все ориентированные рёбра, исходящие из вершины $v$.

Неориентированное ребро $(u, v)$ в таком случае представляется двумя ориентированными рёбрами $(u, v)$ и $(v, u)$ соответственно.

### C++

Используется вектор векторов (`std::vector`).

```cpp
/*
 edge_t - псевдоним для типа ребра
 в простейшем случае edge_t = int.
*/

// n - количество вершин в графе
// e_cnt - количество рёбер в графе

using edge_t = int;

std::vector<std::vector<edge_t>> graph(n);
for (int it = 0; it < e_cnt; ++it) {
  int u, v;
  std::cin >> u >> v;
  --u, --v;

  graph[u].emplace_back(v);
  graph[v].emplace_back(u);
}
```

## Компонента связности

Максимальный по включению набор вершин $V = (v_1, v_2, \dots, v_k)$ такой, что для любой пары $1 \le i \ne j \le k$ существует путь из вершины $v_i$ до $v_j$.

# Полезные источники

- Алгоритмика.
  - [Графы. Определение и термины](https://ru.algorithmica.org/cs/graph-traversals/)
  - [Графы. Хранение](https://ru.algorithmica.org/cs/graph-traversals/storing-graphs/)
- Codeforces.EDU
  - [Основы теории графов](https://codeforces.com/edu/course/2/lesson/8)
