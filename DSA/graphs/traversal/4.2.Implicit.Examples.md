# Примеры неявных графов

## Обход по 4-связной сетке

### Дано

Есть 2D-сетка из $N$ строк и $M$ столбцов.

Некоторые клетки заняты стенками, в которые нельзя переходить.

Из клетки $(x, y)$ можно переместиться в одну из четырёх клеток, если такая **существует**:

- $(x - 1, y)$;
- $(x + 1, y)$;
- $(x, y - 1)$;
- $(x, y + 1)$.

Необходимо построить маршрут из клетки $(xs, ys)$ до $(xf, yf)$.

### Решение

По сути в условии напрямую заданы 4 преобразования-вектора:

- $(-1, 0)$;
- $(1, 0)$;
- $(0, -1)$;
- $(0, 1)$.

Достаточно сохранить их в массив до начала обхода.

Правило применимости одинаково для всех преобразований: новые координаты не должны выходить за пределы сетки.

### C++

```cpp

using ii = pair<int, int>;

vector<ii> steps = {
  {-1, 0},
  {1, 0},
  {0, -1},
  {0, 1}
};

// правило применимости для координаты
auto check = [&](int index, int size) {
  return 0 <= index && index < size;
}

...

// генерация соседей вершины (x, y)

vector<ii> edges;
for (auto& [dx, dy] : steps) {
  int x_to = x + dx, y_to = y + dy;

  if (!check(x_to, n)) continue;
  if (!check(y_to, m)) continue;

  if (field[x_to][y_to] == wall) continue; // не идем в стену

  edges.emplace_back(x_to, y_to);
}

// далее следует обход соседей аналогично явному графу

for (auto& [x_to, y_to] : edges) {
  if (visited[x_to][y_to] || waiting.contains(x_to, y_to)) continue;

  proc_edge(x, y, x_to, y_to);
  waiting.push(x_to, y_to);
}
```

**Обратите внимание**: создавать промежуточный вектор `edges` не всегда является необходимым и удобным.

В простых задачах можно объединить генерацию и обход соседей:

```cpp

// генерация И обход соседей вершины (x, y)

for (auto& [dx, dy] : steps) {
  int x_to = x + dx, y_to = y + dy;

  if (!check(x_to, n)) continue;
  if (!check(y_to, m)) continue;

  if (field[x_to][y_to] == wall) continue; // не идем в стену

  if (visited[x_to][y_to] || waiting.contains(x_to, y_to)) continue;

  proc_edge(x, y, x_to, y_to);
  waiting.push(x_to, y_to);
}
```

## Обход по 8-связной сетке

### Дано 

Задача аналогична 4-связной сетке, только теперь у клетки $(x, y)$ есть 8 соседей:

- 4 соседа по стороне;
- 4 соседа по углу.

### Решение

Теперь векторы для преобразования проще создать программно, чем вписывать руками.

### C++

```cpp

vector<ii> steps;
for (int dx = -1; dx <= 1; ++dx) {
  for (int dy = -1; dy <= 1; ++dy) {
    if (dx * dx + dy * dy == 0) continue; // переход в себя
    steps.emplace_back(dx, dy);
  }
}

```

## Обход шахматным конём

### Дано

На шахматной доске $N \times M$ стоит шахматный конь.

Необходимо найти маршрут перемещения шахматного коня из $(xs, ys)$ в $(xf, yf)$.

### Решение

Напомним, что любой шаг шахматного коня по абсолютной величине равен либо $(1, 2)$, либо $(2, 1)$.

Рассмотрим все возможные целочисленные сдвиги с абсолютной величиной координат $\le 2$.

Можно заметить, что только шагам коня соответствует перемещение на $\sqrt{5}$ в Евклидовой метрике.

Воспользуемся этим свойством, чтобы легко сгенерировать список всех возможных шагов.

### C++

```cpp

vector<ii> steps;
int knight_len = 2 * 2 + 1 * 1;
for (int dx = -2; dx <= 2; ++dx) {
  for (int dy = -2; dy <= 2; ++dy) {
    if (dx * dx + dy * dy != knight_len) continue; // проверяем квадрат перемещения
    steps.emplace_back(dx, dy);
  }
}

```
