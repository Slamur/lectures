# Обход графа

Будем называть **обходом графа** процесс вычисления какой-либо информации о структуре графа с помощью итеративного анализа вершин и рёбер.

## Обход соседей вершины

Основа большинства обходов графа - перебор всех рёбер, инцидентных вершине $v$.

Асимптотически обход соседей выполняется за $O(d^{out}_v)$.

### C++

```cpp

// process - какая-то логика обработки ребра (v_from, v_to)

for (int v_to : graph[v]) {
  process(v, v_to);
}

```

## Обход компоненты связности

### Общий принцип

Рассмотрим общий принцип обхода одной компоненты связности:

#### Инициализация

- создаётся булевый массив "посещенности" вершин;
- подготавливается структура хранения "ожидающих обработки" вершин;
- ожидающей становится *стартовая* вершина (иногда несколько).

#### Выполнение

- выбирается одна из "ожидающих" вершин;
- выбранная вершина помечается как "посещенная";
- текущая вершина обрабатывается "на входе";
- производится *обход соседей* выбранной вершины;
- все **непосещенные** соседи добавляются к "ожидающим";
- после обхода соседей текущая вершина обрабатывается "на выходе".

#### Завершение

Обход завершается, когда не осталось ни одной "ожидающей" вершины.

### Асимптотика

Пусть компонента связности содержит $V$ вершин и $E$ рёбер.

В таком случае асимптотика обхода будет равна $O(V \cdot (pop + vproc) + E \cdot eproc + V \cdot push)$, где

- *pop* - стоимость **выбора** "ожидающей" вершины и её **удаления** из структуры;
- *vproc* - стоимость обработки вершины на "входе" / "выходе";
- *eproc* - стоимость обработки ребра;
- *push* - стоимость добавления вершины к "ожидающим".

### Альтернативы

Иногда удобнее делать всех соседей "ожидающими", но не обрабатывать повторно уже посещенные вершины.

В таком случае асимптотика будет $O(V \cdot (pop + vproc) + E \cdot (eproc + push))$.

Хотя асимптотика выглядит хуже - зачастую разница невелика, поэтому выбор зависит от предпочтений в реализации.

### C++

```cpp

void traverse(int start) {
  vector<bool> visited(n, false); // массив посещенности
  data_structure<int> waiting; // ожидающие вершины

  waiting.push(start);
  while (waiting.size() > 0) {
    int v = waiting.pop();
    visited[v] = true;

    proc_in(v); // обработка "на входе"

    for (int v_to : graph[v]) {
        if (visited[v_to]) continue;
        proc_edge(v, v_to); // обрабатываем ребро
        waiting.push(v_to);
    }

    proc_out(v); // обработка "на выходе"
  }
}
```

## Обход нескольких компонент связности

Если граф не является связным, то необходимо вызвать обход для каждой отдельной компоненты.

### Общий принцип

Переберём все вершины графа по очереди:

- если вершина уже посещена, то ничего не делаем;
- иначе мы нашли стартовую вершину в еще необработанной компоненте:
  - обрабатываем событие "нашли новую компоненту";
  - вызываем обход, используя текущую вершину как *стартовую*.

Обратите внимание, что массив посещенности должен быть **создан один раз** и являться **глобальным** по отношению к функции обхода.

### Асимптотика

Пусть граф состоит из $K$ компонент связности; $i$-ая компонента содержит $V_i$ вершин и $E_i$ рёбер.

Суммарная сложность получается равной $O(K \cdot cproc + \sum{V_i} + \sum{E_i})$, где 

- *cproc* - стоимость обработки события "найдена новая компонента".

После замены $\sum{V_i}$ на $V$ и $\sum{E_i}$ на $E$ получим асимптотику $O(V + E)$ для **обходов** всех компонент суммарно.

### C++

```cpp

vector<bool> visited;

void traverse(int start) {
 ...
}

...

visited.assign(n, false);

for (int v = 0; v < n; ++v) {
  if (visited[v]) continue;

  new_component(); // обработали событие "нашли новую компоненту"
  traverse(v); // вызвали обход от v
}

```
