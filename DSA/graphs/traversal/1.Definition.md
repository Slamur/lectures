# Обход графа

Будем называть **обходом графа** процесс вычисления какой-либо информации о структуре графа с помощью итеративного анализа вершин и рёбер.

## Обход соседей вершины

Основа большинства обходов графа - перебор всех рёбер, инцидентных вершине $v$.

Асимптотически обход соседей выполняется за $O(d^{out}_v)$.

### C++

```cpp

// process - какая-то логика обработки ребра (v_from, v_to)

for (int v_to : graph[v]) {
  process(v, v_to);
}

```

## Обход компоненты связности

Далее будет приведено формальное описание, подходящее под подавляющее большинство используемых в современной науке обходов.

В то же время конкретные обходы будут иметь более простые описания и реализации вследствие привязки к конкретным структурам и другим аспектам.

Данное описание не является призывом к действию, а нужно для более четкого понимания происходящих процессов.

### Общий принцип

Рассмотрим общий принцип обхода одной компоненты связности:

#### Инициализация

- создаётся булевый массив "посещенности" вершин;
- подготавливается структура хранения "ожидающих обработки" вершин;
- заводится массив "указателей" на первое необработанное исходящее ребро каждой вершины;
- ожидающей становится *стартовая* вершина (иногда несколько).

#### Выполнение

На каждой итерации:

- Выбирается *первая* из "ожидающих" вершин $v$.
- Если $v$ ранее не посещалась, то $v$ обрабатывается "на входе" и помечается "посещенной".
- Если все исходящие рёбра из $v$ уже обработаны, то $v$ обрабатывается "на выходе" и удаляется из "ожидающих".
- Иначе обрабатывается текущее ребро в вершину $to$:
  - если $to$ не посещена ранее и не является уже ожидающей, то она добавляется к "ожидающим".
  
#### Завершение

Обход завершается, когда не осталось ни одной "ожидающей" вершины.

### Асимптотика

Пусть компонента связности содержит $V$ вершин и $E$ рёбер.

В таком случае асимптотика обхода будет равна $O(V \cdot (get + remove + vproc) + E \cdot eproc + V \cdot add)$, где

- *get* и *remove* - стоимость **выбора** и **удаления** первой из "ожидающих" вершин;
- *vproc* - стоимость обработки вершины на "входе" / "выходе";
- *eproc* - стоимость обработки ребра;
- *add* - стоимость **добавления** вершины к "ожидающим".

### Альтернативы

Иногда удобнее добавлять всех соседей к "ожидающим", но не обрабатывать повторно уже посещенные вершины.

В таком случае асимптотика будет $O(V \cdot (get + remove + vproc) + E \cdot (eproc + add))$.

Хотя асимптотика выглядит хуже - зачастую разница невелика, поэтому выбор зависит от предпочтений в реализации.

### C++

```cpp

void traverse(int start) {
  vector<bool> visited(n, false);
  data_structure<int> waiting;
  vector<int> cur_edges(n, 0);

  waiting.push(start);
  while (waiting.size() > 0) {
    int v = waiting.get();
    
    if (!visited[v]) {
      proc_in(v); // обработка "на входе"
      visited[v] = true;
    }

    int e = cur_edges[v];
    if (e == graph[v].size()) {
      proc_out(v); // обработка "на выходе"
      waiting.remove();
    } else {
      int to = graph[v][e];
      cur_edges[v]++;

      proc_edge(v, to); // обработали ребро

      if (visited[to]) continue; // сосед уже посещен
      if (waiting.contains(to)) continue; // сосед уже ожидает

      waiting.add(to);      
    }
  }
}
```

## Обход нескольких компонент связности

Если граф не является связным, то необходимо вызвать обход для каждой отдельной компоненты.

### Общий принцип

Переберём все вершины графа по очереди:

- если вершина уже посещена, то ничего не делаем;
- иначе мы нашли стартовую вершину в еще необработанной компоненте:
  - обрабатываем событие "нашли новую компоненту";
  - вызываем обход, используя текущую вершину как *стартовую*.

Обратите внимание, что массив посещенности должен быть **создан один раз** и являться **глобальным** по отношению к функции обхода.

### Асимптотика

Пусть граф состоит из $K$ компонент связности; $i$-ая компонента содержит $V_i$ вершин и $E_i$ рёбер.

Суммарная сложность получается равной $O(K \cdot cproc + \sum{V_i} + \sum{E_i})$, где 

- *cproc* - стоимость обработки события "найдена новая компонента".

После замены $\sum{V_i}$ на $V$ и $\sum{E_i}$ на $E$ получим асимптотику $O(V + E)$ для **обходов** всех компонент суммарно.

### C++

```cpp

vector<bool> visited;

void traverse(int start) {
 ...
}

...

visited.assign(n, false);

for (int v = 0; v < n; ++v) {
  if (visited[v]) continue;

  proc_new_comp(); // обработали событие "нашли новую компоненту"
  traverse(v); // вызвали обход от v
}

```
