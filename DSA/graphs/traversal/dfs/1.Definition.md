# Обход в глубину (depth-first search)

Обход графа, использующий **стек** для хранения _ожидающих_ вершин.

## Смысл алгоритма

На каждой итерации обрабатывается самая последняя из добавленных в "ожидание".

Хорошей аналогией является блуждание человека по лабиринту с комнатами и коридорами:

- при первом входе человек помечает текущую комнату, чтобы не повторяться;
- при переходе в соседнюю комнату человек сначала исследует всё относительно неё, а только потом вернётся в текущую.

Получается, что человек **углубляется** в лабиринт в каком-то направлении, пока не уткнётся в тупик / уже исследованные комнаты, после чего возвращается в предыдущую локацию.

## Нерекурсивная реализация

Является максимально близкой по духу к обобщенной реализации обхода.

Соответственно кода требуется достаточно много, но зато работает на Python.

### C++

Достаточно произвести замены в обобщенной реализации:

- "data_structure" на "vector";
- "get" на "back";
- "remove" на "pop_back";
- "add" на "push_back".

## Рекурсивная реализация

Как известно, рекурсивный вызов сохраняет данные в системный **стек**.

Воспользуемся данным свойством:

- для непосещенных соседей будем вызывать рекурсивно функцию обхода - это автоматически положит их в системный стек.
- заодно на стеке сохранится информация о текущей вершине и индексе перебираемого ребра (альтернатива внешнему массиву указателей).

### С++

```cpp

void dfs(int v) {
  visited[v] = true;

  proc_in(v);

  for (int to : graph[v]) {
    if (visited[to]) continue;

    proc_edge(v, to);

    dfs(to);
  }

  proc_out(v);
}

```
