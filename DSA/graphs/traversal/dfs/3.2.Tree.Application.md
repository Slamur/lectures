# Применения обхода в глубину в деревьях

## Вычисление "на возврате"

По сути является адаптацией "[Вычисления функции на компоненте](https://github.com/Slamur/lectures/blob/main/DSA/graphs/traversal/dfs/2.Application.md#вычисление-функции-от-компоненты-связности)". 

- вызываем рекурсивное вычисление в ребёнке;
- объединяем результат из ребёнка с собственным.

### C++

```cpp

int dfs(int v, int p = -1) {
  int res_v = a[v];
  for (int to : graph[v]) {
    if (to == p) continue;

    int res_to = dfs(to, v);
    res_v = f(res_v, res_to);
  }
  
  return res_v;
}
```

## Вычисление "на спуске"

Проталкиваем информацию в детей, попутно обновляя её.

- обновляем информацию для ребёнка;
- передаём обновленную информацию в рекурсивный вызов;
- откатываем информацию к прежнему значению.

### C++

```cpp

void dfs(int v, int p = -1, int info) {
    proc_in(v, info);

    for (int to : graph[v]) {
      if (to == p) continue;

      update(v, to, info);
      dfs(to, v, info);
      reverse(v, to, info);
    }
}

```

# Примеры применения 

## Глубины

Вычисление "на спуске":

- передаём текущую глубину вершины;
- для ребёнка увеличиваем глубину на 1.

### C++

```cpp

void dfs(int v, int p = -1, int depth) {
  depths[v] = depth;

  for (int to : graph[v]) {
    if (to == p) continue;
    dfs(to, v, depth + 1);
  }
}
```

## Высоты

Вычисление "на возврате":

- вычисляем высоты детей;
- высота вершина равна максимуму из глубин детей + 1.

### C++

```cpp
int dfs(int v, int p = -1) {
  int h_v = 0;
  for (int to : graph[v]) {
    if (to == p) continue;

    int h_to = dfs(to, v);
    h_v = max(h_v, h_to + 1);
  }

  return h_v;
}
```

## Количество листьев в поддереве

Вычисление "на возврате":

- суммируем количества из детей;
- отдельно обрабатываем листовой корень дерева (обычно его не считают).

### C++

```cpp
int dfs(int v, int p = -1) {
  bool is_leaf = (graph[v].size() < 2);
  is_leaf &= (p != -1); // если корень не надо учитывать

  int cnt_v = is_leaf;

  for (int to : graph[v]) {
    if (to == p) continue;

    int cnt_to = dfs(to, v);
    cnt_v += cnt_to;
  }

  return cnt_v;
}
```

## Пушистый хвост

### Дано

Для каждой вершины известно, является ли она "пушистой".

Назовём _хвостом_ вершины $v$ последние $K$ вершин на пути из корня в вершину $v$.

Для каждой вершины $v$ определите, состоит ли её хвост только из "пушистых" вершин.

### Решение

Вычисление "на спуске":

- передаём количество подряд идущих пушистых вершин;
- если вершина пушистая - увеличиваем счётчик; иначе обнуляем.
- если счётчик $\ge K$ - хвост "пушистый".

### C++

```cpp

void dfs(int v, int p = -1, int fluff_in_row) {
    if (!fluffy[v]) fluff_in_row = 0;
    else fluff_in_row++;

    is_fluff[v] = fluff_in_row >= k;

    for (int to : graph[v]) {
      if (to == p) continue;

      dfs(to, v, fluff_in_row);
    }
}

```

## K-ый предок

### Дано

Назовём вершину $u$ $k$-предком вершины $v$, если:

- $u$ является предком вершины $v$;
- глубина вершины $u$ ровно на $k$ меньше глубины вершины $v$.

Для каждой вершины $v$ найдите её $k$-предка или определите, что такого нет.

### Решение

Вычисление "на спуске":

- поддерживаем динамический массив всех вершин в пути от корня до текущей;
- если размер массива $\ge K$, то заносим в ответ $K$-ый с конца элемент массива.
- на входе добавляем вершину в конец массива; на выходе - удаляем.

### C++

```cpp

void dfs(int v, int p = -1, vector<int>& path) {
    if (path.size() >= k) {
      ans[v] = path[path.size() - k];
    }

    path.push_back(v);

    for (int to : graph[v]) {
      if (to == p) continue;

      dfs(to, v, path);
    }

    path.pop_back();
}


```
