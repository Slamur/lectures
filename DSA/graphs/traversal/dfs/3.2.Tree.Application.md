# Применения обхода в глубину в деревьях

## Вычисление "на возврате"

По сути описано в "Вычислении функции на компоненте". 

- вызываем рекурсивное вычисление в ребёнке;
- объединяем результат из ребёнка с собственным.

### C++

```cpp

int dfs(int v, int p = -1) {
  int res_v = ...;
  for (int to : graph[v]) {
    if (to == p) continue;

    int res_to = dfs(to, v);
    res_v = f(res_v, res_to);
  }
  
  return res_v;
}
```

## Вычисление "на спуске"

Проталкиваем информацию в детей, попутно обновляя её.

- обновляем информацию для ребёнка;
- передаём обновленную информацию в рекурсивный вызов;
- откатываем информацию к прежнему значению.

### C++

```cpp

void dfs(int v, int p = -1, int info) {
    proc_in(v, info);

    for (int to : graph[v]) {
      if (to == p) continue;

      update(v, to, info);
      dfs(to, v, info);
      reverse(v, to, info);
    }
}

```

# Примеры применения 

## Вычисление глубины вершины

Вычисление "на спуске":

- передаём текущую глубину вершины;
- для ребёнка увеличиваем глубину на 1.

### C++

```cpp

void dfs(int v, int p = -1, int depth) {
  depths[v] = depth;

  for (int to : graph[v]) {
    if (to == p) continue;
    dfs(to, v, depth + 1);
  }
}
```

## Вычисление высоты вершины

Вычисление "на возврате":

- вычисляем высоты детей;
- высота вершина равна максимуму из глубин детей + 1.

### C++

```cpp
int dfs(int v, int p = -1) {
  int h_v = 0;
  for (int to : graph[v]) {
    if (to == p) continue;

    int h_to = dfs(to, v);
    h_v = max(h_v, h_to + 1);
  }

  return h_v;
}
```
