# Применения обхода в глубину

## Вычисление функции от компоненты связности

### Дано

1. Пусть $F$ - функция от двух параметров (бинарная), обладающая свойствами

- **коммутативности**: $F(A, B) = F(B, A)$;
- **ассоциативности**: $F(A, F(B, C)) = F(F(A, B), C)$.

Примерами таких функций могут служить:

- сложение;
- минимум / максимум.

2. Каждой вершине $v$ сопоставлено значение $A_v$.

3. Задана вершина $S$, входящая в компоненту связности $C = (v_1, v_2, \dots, v_k)$.

Требуется вычислить значение $F(A_{v_1}, A_{v_2}, \dots, A_{v_k})$.

### Решение

Запустим обход в глубину от вершины $S$.

При обработке вершины $v$

- инициализируем результат $res_v$ значением $A_v$ (обработка **на входе**)
- для каждого необработанного соседа $to$ вычислим рекурсивно результат $res_{to}$;
- "объединим" результаты $res_v = F(res_v, res_{to})$ (обработка **ребра**);
- вернём результат $res_v$ из рекурсии (обработка **на выходе**).

### C++

```cpp

res_t dfs(int v) {
  visited[v] = true;

  int res_v = a[v];
  for (int to : graph[v]) {
    if (visited[to]) continue;

    int res_to = dfs(to);
    res_v = F(res_v, res_to);
  }

  return res_v;
}

```

## Самый полный обход графа

### Дано

Страна Графляндия состоит из $N$ городов и $M$ двусторонних дорог между городами.

Исследователь планирует пройти по каждой дороге **в обе стороны**, начав свой путь в городе $S$.

Выведите маршрут минимальной длины, который позволит исследователю достичь его цели.

### Решение

При _входе_ в вершину $v$ добавим её в маршрут.

Если вершина $v$ была посещена ранее - сразу же закончим обход.

Рассмотрим обход соседей вершины $v$. Пусть в данный момент рассматривается ребро $(v, to)$:

- если $to$ является _родителем_ вершины $v$ - переходим к следующему ребру;
- вызовем обход из вершины $to$ независимо от её посещенности;
- после возврата из $to$ добавим в маршрут вершину $v$, что будет соответствовать возврату по ребру $(to, v)$.

### C++

```cpp

void dfs(int v, int p = -1) {
  path.push_back(v);
  if (visited[v]) return;
  
  visited[v] = true;
  for (int to : graph[v]) {
    if (to == p) continue;
    dfs(to, v);
    path.push_back(v);
  }
}

```
