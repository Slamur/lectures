# Доступ к параметрам

Любые функции обхода, кроме основных (**изменяемых**) параметров, обладают набором информативных (**неизменяемых**).

Как минимум, информативным параметром для любого обхода является хранилище рёбер графа (списки смежности и т.д.).

В случае нескольких компонент связности таким информативным становится массив "посещенности".

**Примечание**: Неизменным является указатель на сам массив.
Содержимое массива обязано изменяться в силу фундаментальных принципов обхода.

В данной главе будут рассмотрены основные способы обеспечения доступа к информативным параметрам.

## Обход как функция

Функция обхода представляется независимой функцией, вызываемой из основного решения.

### Параметры функции

Информативные данные передаются в качестве **параметров функции** наравне с основными параметрами.

Основными минусами подхода являются:

- Разрастание списка параметров;
- Ускоренное захламление стека рекурсии.

#### C++

```cpp

void traverse(int start, const vector<vector<int>>& graph, vector<bool>& visited) {
  ...
}
```

### Глобальные переменные

Неизменяемые параметры объявляются как **глобальные переменные**.

Основными минусами подхода являются:

- Глобальные переменные - не самый хороший стиль программирования.
- Инициализация глобальных переменных отделяется от их объявления.

#### C++

```cpp

vector<vector<int>> graph;
vector<bool> visited;

void traverse(int start) {
  ...
}

void solve() {
   graph.assign(n);
   visited.assign(n, false);

   ...
   traverse(start); 
}

```

## Обход как метод класса / структуры.

В таком случае все неизменяемые параметры становятся **полями** структуры, а сам обход - её **методом**.

Основными минусами подхода являются:

- Может получиться слишком много дополнительного кода.

#### C++

```cpp

struct Process {
  vector<vector<int>> graph;
  vector<bool> visited;

  void traverse(int start) {
    ...
  }
}

void solve() {
   Process proc(graph, visited);
   ...
   proc.traverse(start);
}
```

## Обход как лямбда-функция

Все информативные параметры становятся **локальными переменными** в методе, вызывающем обход.

Сам обход описывается лямбда-функцией, имеющей доступ к необходимым "извне" параметрам.

Данный подход сочетает краткость записи из способа с глобальными переменными, но сохраняет *локальность* данных.

#### C++

```cpp
void solve() {

  vector<vector<int>> graph(n);
  vector<bool> visited(n, false);

  auto traverse = [&](int start) {
    ...
  };

  traverse(start);
}
```
