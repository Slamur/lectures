# Итератор

**Итератор** - некий объект, указывающий на значение в рамках заданной последовательности.

Базовые действия, общие для всех итераторов:

- получить соответствующее ему значение;
- перейти к следующему элементу в последовательности (точнее следующему итератору).
  - либо сказать, что элементы закончились.

## Итератор и указатель

По своей сути итератор является обобщением идеи **указателя** на значение в памяти. Если вы рассмотрите память как последовательность ячеек, то данное обобщение становится более логичным.

Из этого можно сделать и обратный вывод - вы можете использовать итератор не только для непосредственного итерирования по последовательности, но и для хранения "указателя на элемент в последовательности".

## Итератор и индекс

Фактически индекс является наиболее простым примером итератора - одно целое число.

Легко заметить, что все описанные выше операции определены для индекса:

- получение соответствующее значение выполняется через `operator[](index)`;
- переход к следующему элементу выполняется через `index++`;
- элементы закончились, когда `index == size`.

## Итерирование через итератор

Любая последовательность обычно имеет функционал получения итератора, указывающего на **первый элемент** в обходе.

Поэтому общий подход можно записать следующим образом:

```
Iterator it = iterator(sequence);
while (true)
{
  Value value = value(it);
  // process(value)

  if (finished(it)) break;
  it = next(it);
}
```

Но различные языки программирования могут реализовывать данный шаблон совершенно по-разному.

В рамках данной лекции мы подробно рассмотрим итераторы в C++ и кратко ознакомимся с итераторами в Java и Python.

### Foreach

Часто языки предоставляют синтаксический сахар итерирования через последовательности с помощью видоизменения цикла `for`.

Такая конструкция называется `for-each` и в общем виде выглядит примерно так:

```
for-each (Value value in sequence)
{
  // process (value)
}
```

Чаще всего `for-each` синтаксис получается сильно проще, чем явная итерация через итератор.

## Инвалидация итераторов

В самом базовом случае итератор должен корректно указывать на текущий элемент, а также быть способен верно определить следующий элемент в порядке обхода.

Из этого следует два факта:

- **не гарантируется**, что итераторы на **уже просмотренные** элементы будут валидны.
- **не гарантируется**, что **изменение структуры последовательности** во время итерации сохранит валидность текущего итератора.

Второй факт особенно важен, так как зачастую может приводить к неожиданным для вас эффектам.

Различные виды последовательностей дают некоторые дополнительные гарантии и/или позволяют производить некоторые виды изменений.

Но в общем случае **не рекомендуется** реализовывать алгоритм, использующий модификацию структуры последовательностей в процессе обхода итератором (включая циклы `for-each`).