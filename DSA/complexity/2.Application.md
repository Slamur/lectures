## Стандартные асимптотики

Рассмотрим функции, с помощью комбинации которых можно оценить асимптотику большинства алгоритмов:

### O(1) - константа

Любая операция, считающаяся не зависящей от размера параметров (близкое к фиксированному количество тактов):

- Арифметические операции;
- Условный оператор;
- Обращение к элементу массива;
- И т.д.

### O(logN) - логарифм

**Логарифм** числа $N$ по основанию $A$ равен $B$, если $A^B = N$.

Обозначается как $log_A{N} = B$.

Логарифм растет достаточно медленно - например, логарифм от $10^{18}$ по основанию $2$ равен приблизительно $60$ (т.е. $2^{60}$ приблизительно равно $10^{18}$).

При описании асимптотики основание логарифма не пишут, так как для разных оснований отличается лишь константный множитель.

#### Доказательство

<details> <summary> </summary>

Рассмотрим $log_A{N}$ и $log_B{N}$.

По свойству логарифмов $log_B{N} = \frac{log_B{N}}{log_B{A}}$.

Получается, что $log_B{N} = log_A{N} \cdot log_B{A}$, где $log_B{A}$ - константа, не зависящая от $N$.

</details>

	3. O(N^k) - полиномиальная зависимость.

	4. O(a^N) - экспоненциальная зависимость. Здесь число a имеет значение, так как при переходе от a^n к b^n появляется коэффициент (a / b) ^ n, зависящий от n.

	5. O(N!) - факториал от N - очень быстро растет, но и решения с такой асимптотикой бывают.
	
Распишем частные случаи асимптотик и примерные значения N, при которых такая асимптотика еще позволит вам уложиться в 1 секунду:

	1. O(1) - любое N;
	2. O(logN) - любое N, влезающее в стандартные типы данных - слишком медленно растет :D
	3. O(N^(1 / 2)), O(N^(1 / 3)) - квадратный и кубический корни из N - растет медленно, но растет - 10^15-10^16 для квадратного корня и 10^18 для кубического;
	4. O(N) - "линия" - 10^7 - 10^8;
	5. O(N * logN) - "Н лог Н" - 10^5 - 10^6 (зависит от основания логарифма и опущенной константы).
	6. O(N * sqrt(N)) - 10^5.
	7. O(N^2) - "квадрат" - 10^4;
	8. O(N^3) - "куб" - 300 - 500;
	9. O(2^N), O(N * 2^N) - 20 - 24 (при 23-24 на грани).
	10. O(3^N) - примерно 14-16.
	11. O(1.5 ^ N) - 1.5 - приближение числа (1 + sqrt(5)) / 2 - это скорость роста значений чисел Фибоначчи - примерно 30 (хз, точно не считал, лучше на калькуляторе проверять).

Рассмотрим несколько частных примеров вычисления асимптотики:

	1. Последовательное выполнение алгоритмов.
	
		function T(N) {
			F(N);
			G(N);
		}	
	
В таком случае асимптотика T(N) будет равна O(F(N) + G(N)).
	
	2. Циклическое выполнение какого-либо алгоритма.
	
		for (int i = 0; i < M; ++i) {
			F(N);
		}
		
Проводя аналогии с предыдущим примером, здесь мы M раз выполняем алгоритм с асимптотикой O(F(N)), итого O(M) * O(F(N)) = O(M * F(N)).
	
	3. Циклическое уменьшение/увеличение величины в A раз.
	
		function F(N) {
			result = 0;
			while (N > 0) {
				N /= A;
				result = result + 1;
			}
			
			return result;
		}
		
Здесь result будет равно минимальной степени A, при которой A^(result - 1) <= N < A^(result), откуда result = log_A(N) и асимптотика F(N) = O(result) = O(logN).
Для закрепления материала предлагаем вам подумать над асимптотикой алгоритмов для решения следующих задач (операции сложения, сравнения и подобные делаются за O(1)):

	1.  Найти сумму элементов массива A длины N. 
	2.  Найти максимум, минимум в массиве A длины N; найти и максимум, и минимум одновременно - различаются ли оценки для этих заданий? 
	3.  Вывести все цифры числа Х через пробел (в оценке должен быть только Х).
	4.  Найти точку M - центр отрезка AB по координатам точек A и B (в двумерной плоскости)
	5.  Найти индекс строки матрицы A из целых чисел размера NxM (N cтрок, в каждой M столбцов) с минимальной суммой; с минимальным первым элементом.
	6.  Сравнить лексикографически (в алфавитном порядке) две строки S1 и S2.

Ответы к данным задачам расположены на следующем листе.

Ответы на простые задачи:
O(N) - просто пробежимся циклом по массиву.
O(N); поиск минимума и максимума вместе можно сделать за 3N/2 операций (подумайте, как), но это все равно O(N).
Количество цифр в числе можно оценить максимальной степенью 10 в числе, а это логарифм - O(logN).
Точка вычисляется по формуле, а значит O(1).
Для каждой строки надо посчитать сумму за O(M), всего строк N, поэтому O(NM). Первый элемент ищется за O(1), значит во втором варианте O(N).
Строки сравниваются посимвольно, пока одна из строк не закончится, значит O(min(|S1|, |S2|)).

