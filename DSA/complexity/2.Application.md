# Операции над асимптотиками

## Сложение

Пусть алгоритм $T$ состоит из последовательного выполнения алгоритмов $F$, $G$, $H$. 

	Алгоритм T(N) {
		F(N);
		G(N);
		H(N);
	}

В таком случае асимптотика $O(T(N))$ будет равна **сумме** асимптотик $O(F(N) + G(N) + H(N))$.

## Умножение

Пусть алгоритм $T$ состоит из $M$ итераций выполнения алгоритма $F$.

 	Алгоритм T(N) {
		Повторить M раз {
			F(N);
		}
  	}

В таком случае асимптотика $O(T(N))$ будет равна **произведению** асимптотик $O(M \cdot F(N))$.

# Стандартные виды асимптотик

Рассмотрим базовые функции, с помощью комбинации которых можно оценить асимптотику большинства алгоритмов.

Для каждой приведем верхнюю **оценку** $N$, при которой данная функция "умещается в секунду" (значение порядка $10^7 - 10^8$).

## "Малые" асимптотики

### O(1) - константа

Любая операция, считающаяся не зависящей от размера параметров (близкое к фиксированному количество тактов):

#### Примеры

- Арифметические операции;
- Условный оператор;
- Обращение к элементу массива;
- И т.д.

### O(logN) - логарифм

**[Логарифм](https://ru.wikipedia.org/wiki/Логарифм)** числа $N$ по основанию $A$ равен $B$, если $A^B = N$.

Обозначается как $log_A{N} = B$.

#### Примеры

- Количество цифр или бит в числе $N$;
- Количество целочисленных делений числа $N$ на $A$ вплоть до $0$;

<details> <summary> </summary>

div - целочисленное деление.
  
	Алгоритм F(N, A) {
		Пока (N > 0) {
			N = N div A;
		}
	}

</details>

- Деление и вычисление остатка ("быстрый" логарифм).
- Сложение и вычитание [длинных чисел](https://ru.wikipedia.org/wiki/Длинная_арифметика).

#### Отсутствие основания в записи

При описании асимптотики основание логарифма **не пишут**, так как для разных оснований отличается лишь константный множитель.

<details> <summary> </summary>

Рассмотрим $log_A{N}$ и $log_B{N}$.

По свойству замены основания $log_B{N} = log_A{N} \cdot log_B{A}$.

Видно, что логарифмы отличаются в $log_B{A}$ раз - константа, не зависящая от $N$.

</details>

#### Верхняя оценка N

По определению для любого целого числа, представимого в $64$-битном типе, логарифм не превышает $64$.

Поэтому обычно логарифм не является ограничением на $N$, но его важно учитывать при перемножении асимптотик.

## Полиномиальные асимптотики (N в степени К)

### O(N) - линейная

#### Примеры

Могут показаться немного очевидными)

- Количество элементов в массиве / символов в строке длины $N$;
- Количество натуральных чисел от $1$ до $N$.

#### Верхняя оценка N

Если говорить именно про $O(N)$ операций, то обычно $N \le 10^6 - 10^7$.

С другой стороны, зачастую $N$ - суммарный размер входных данных.

Так как вы должны успеть прочесть / сгенерировать все входные данные за $O(N)$, то и любая обработка $O(1)$ за "размер ввода" должна заходить.

### O(N^2) - квадратичная

#### Примеры

- Сортировка массива длины $N$ пузырьком / вставками / выборкой.
- Сумма натуральных чисел от $1$ до $N$.
- Количество пар натуральных чисел $(i, j)$, где $1 \le i \le j \le N$.

#### Верхняя оценка N

Формально $N \le 10^4$.

Но всё очень сильно зависит от асимптотики и константы отдельных операций.

Чаще всего можно встретить $O(N^2)$ при $N \le 2 \cdot 10^3 - 5 \cdot 10^3$.

### O(sqrtN) - квадратный корень

#### Примеры

- Поиск делителей числа $N$;
- Максимальный $K$ такой, что сумма $1 + 2 + \dots + K \le N$.

#### Верхняя оценка N

Формально $N \le 10^{14} - 10^{16}$, но обычно в задачах на такую асимптотику встречается $N \le 10^{12}$.

### O(cbrtN) - кубический корень

#### Примеры

- Общепринятая примерная оценка количества делителей $N$.

#### Верхняя оценка N

Обычно $O(cbrtN)$ является множителем, а не основной частью.

Но формально для любого 64-битного $N$ такая асимптотика должна заходить.

	4. O(a^N) - экспоненциальная зависимость. Здесь число a имеет значение, так как при переходе от a^n к b^n появляется коэффициент (a / b) ^ n, зависящий от n.

	5. O(N!) - факториал от N - очень быстро растет, но и решения с такой асимптотикой бывают.
	
Распишем частные случаи асимптотик и примерные значения N, при которых такая асимптотика еще позволит вам уложиться в 1 секунду:

	1. O(1) - любое N;
	2. O(logN) - любое N, влезающее в стандартные типы данных - слишком медленно растет :D
	3. O(N^(1 / 2)), O(N^(1 / 3)) - квадратный и кубический корни из N - растет медленно, но растет - 10^15-10^16 для квадратного корня и 10^18 для кубического;
	4. O(N) - "линия" - 10^7 - 10^8;
	5. O(N * logN) - "Н лог Н" - 10^5 - 10^6 (зависит от основания логарифма и опущенной константы).
	6. O(N * sqrt(N)) - 10^5.
	7. O(N^2) - "квадрат" - 10^4;
	8. O(N^3) - "куб" - 300 - 500;
	9. O(2^N), O(N * 2^N) - 20 - 24 (при 23-24 на грани).
	10. O(3^N) - примерно 14-16.
	11. O(1.5 ^ N) - 1.5 - приближение числа (1 + sqrt(5)) / 2 - это скорость роста значений чисел Фибоначчи - примерно 30 (хз, точно не считал, лучше на калькуляторе проверять).

Для закрепления материала предлагаем вам подумать над асимптотикой алгоритмов для решения следующих задач (операции сложения, сравнения и подобные делаются за O(1)):

	1.  Найти сумму элементов массива A длины N. 
	2.  Найти максимум, минимум в массиве A длины N; найти и максимум, и минимум одновременно - различаются ли оценки для этих заданий? 
	3.  Вывести все цифры числа Х через пробел (в оценке должен быть только Х).
	4.  Найти точку M - центр отрезка AB по координатам точек A и B (в двумерной плоскости)
	5.  Найти индекс строки матрицы A из целых чисел размера NxM (N cтрок, в каждой M столбцов) с минимальной суммой; с минимальным первым элементом.
	6.  Сравнить лексикографически (в алфавитном порядке) две строки S1 и S2.

Ответы к данным задачам расположены на следующем листе.

Ответы на простые задачи:
O(N) - просто пробежимся циклом по массиву.
O(N); поиск минимума и максимума вместе можно сделать за 3N/2 операций (подумайте, как), но это все равно O(N).
Количество цифр в числе можно оценить максимальной степенью 10 в числе, а это логарифм - O(logN).
Точка вычисляется по формуле, а значит O(1).
Для каждой строки надо посчитать сумму за O(M), всего строк N, поэтому O(NM). Первый элемент ищется за O(1), значит во втором варианте O(N).
Строки сравниваются посимвольно, пока одна из строк не закончится, значит O(min(|S1|, |S2|)).

